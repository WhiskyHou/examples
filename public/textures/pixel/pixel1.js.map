{"version":3,"file":"pixel1.js","sources":["../../../node_modules/@phaserjs/phaser/Phaser4.esm.js","../../../src/textures/pixel/pixel1.ts"],"sourcesContent":["function GetElement(target) {\r\n    let element;\r\n    if (target) {\r\n        if (typeof target === 'string') {\r\n            element = document.getElementById(target);\r\n        }\r\n        else if (typeof target === 'object' && target.nodeType === 1) {\r\n            element = target;\r\n        }\r\n    }\r\n    if (!element) {\r\n        element = document.body;\r\n    }\r\n    return element;\r\n}\n\nfunction AddToDOM(element, parent) {\r\n    const target = GetElement(parent);\r\n    target.appendChild(element);\r\n    return element;\r\n}\n\nfunction DOMContentLoaded(callback) {\r\n    const readyState = document.readyState;\r\n    if (readyState === 'complete' || readyState === 'interactive') {\r\n        callback();\r\n        return;\r\n    }\r\n    const check = () => {\r\n        document.removeEventListener('deviceready', check, true);\r\n        document.removeEventListener('DOMContentLoaded', check, true);\r\n        window.removeEventListener('load', check, true);\r\n        callback();\r\n    };\r\n    if (!document.body) {\r\n        window.setTimeout(check, 20);\r\n    }\r\n    else if (window.hasOwnProperty('cordova')) {\r\n        document.addEventListener('deviceready', check, true);\r\n    }\r\n    else {\r\n        document.addEventListener('DOMContentLoaded', check, true);\r\n        window.addEventListener('load', check, true);\r\n    }\r\n}\n\nfunction ParseXML(data) {\r\n    let xml;\r\n    try {\r\n        const parser = new DOMParser();\r\n        xml = parser.parseFromString(data, 'text/xml');\r\n        if (!xml || !xml.documentElement || xml.getElementsByTagName('parsererror').length) {\r\n            return null;\r\n        }\r\n        else {\r\n            return xml;\r\n        }\r\n    }\r\n    catch (error) {\r\n        return null;\r\n    }\r\n}\n\nfunction RemoveFromDOM(element) {\r\n    if (element.parentNode) {\r\n        element.parentNode.removeChild(element);\r\n    }\r\n}\n\nvar index = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    AddToDOM: AddToDOM,\n    DOMContentLoaded: DOMContentLoaded,\n    GetElement: GetElement,\n    ParseXML: ParseXML,\n    RemoveFromDOM: RemoveFromDOM\n});\n\nlet _audioElement;\r\nfunction CanPlayAudioType(type, audioElement) {\r\n    if (!audioElement) {\r\n        if (!_audioElement) {\r\n            _audioElement = document.createElement('audio');\r\n        }\r\n        audioElement = _audioElement;\r\n    }\r\n    return (audioElement && audioElement.canPlayType(type) !== '');\r\n}\n\nfunction CanPlayM4A(audioElement) {\r\n    return (CanPlayAudioType('audio/x-m4a', audioElement) ||\r\n        CanPlayAudioType('audio/aac', audioElement));\r\n}\n\nfunction CanPlayMP3(audioElement) {\r\n    return CanPlayAudioType('audio/mpeg; codecs=\"mp3\"', audioElement);\r\n}\n\nfunction CanPlayOGG(audioElement) {\r\n    return CanPlayAudioType('audio/ogg; codecs=\"vorbis\"', audioElement);\r\n}\n\nfunction CanPlayOpus(audioElement) {\r\n    return (CanPlayAudioType('audio/ogg; codecs=\"opus\"', audioElement) ||\r\n        CanPlayAudioType('audio/webm; codecs=\"opus\"', audioElement));\r\n}\n\nfunction CanPlayWAV(audioElement) {\r\n    return CanPlayAudioType('audio/wav; codecs=\"1\"', audioElement);\r\n}\n\nfunction CanPlayWebM(audioElement) {\r\n    return CanPlayAudioType('audio/webm; codecs=\"vorbis\"', audioElement);\r\n}\n\nfunction HasAudio() {\r\n    return (window && window.hasOwnProperty('Audio'));\r\n}\n\nfunction HasWebAudio() {\r\n    return (window &&\r\n        (window.hasOwnProperty('AudioContext') || window.hasOwnProperty('webkitAudioContext')));\r\n}\n\nfunction GetAudio() {\r\n    const result = {\r\n        audioData: HasAudio(),\r\n        m4a: false,\r\n        mp3: false,\r\n        ogg: false,\r\n        opus: false,\r\n        wav: false,\r\n        webAudio: HasWebAudio(),\r\n        webm: false\r\n    };\r\n    if (result.audioData) {\r\n        result.m4a = CanPlayM4A();\r\n        result.mp3 = CanPlayMP3();\r\n        result.ogg = CanPlayOGG();\r\n        result.opus = CanPlayOpus();\r\n        result.wav = CanPlayWAV();\r\n        result.webm = CanPlayWebM();\r\n    }\r\n    return result;\r\n}\n\nvar index$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    CanPlayAudioType: CanPlayAudioType,\n    CanPlayM4A: CanPlayM4A,\n    CanPlayMP3: CanPlayMP3,\n    CanPlayOGG: CanPlayOGG,\n    CanPlayOpus: CanPlayOpus,\n    CanPlayWAV: CanPlayWAV,\n    CanPlayWebM: CanPlayWebM,\n    GetAudio: GetAudio,\n    HasAudio: HasAudio,\n    HasWebAudio: HasWebAudio\n});\n\nfunction IsChrome() {\r\n    const chrome = (/Chrome\\/(\\d+)/).test(navigator.userAgent);\r\n    const chromeVersion = (chrome) ? parseInt(RegExp.$1, 10) : 0;\r\n    return {\r\n        chrome,\r\n        chromeVersion\r\n    };\r\n}\n\nfunction IsEdge() {\r\n    const edge = (/Edge\\/\\d+/).test(navigator.userAgent);\r\n    return {\r\n        edge\r\n    };\r\n}\n\nfunction IsFirefox() {\r\n    const firefox = (/Firefox\\D+(\\d+)/).test(navigator.userAgent);\r\n    const firefoxVersion = (firefox) ? parseInt(RegExp.$1, 10) : 0;\r\n    return {\r\n        firefox,\r\n        firefoxVersion\r\n    };\r\n}\n\nfunction IsMSIE() {\r\n    const ie = (/MSIE (\\d+\\.\\d+);/).test(navigator.userAgent);\r\n    const ieVersion = (ie) ? parseInt(RegExp.$1, 10) : 0;\r\n    return {\r\n        ie,\r\n        ieVersion\r\n    };\r\n}\n\nfunction IsiOS() {\r\n    const ua = navigator.userAgent;\r\n    const result = {\r\n        iOS: false,\r\n        iOSVersion: 0,\r\n        iPhone: false,\r\n        iPad: false\r\n    };\r\n    if ((/iP[ao]d|iPhone/i).test(ua)) {\r\n        const match = (/OS (\\d+)/).exec(navigator.appVersion);\r\n        result.iOS = true;\r\n        result.iOSVersion = parseInt(match[0], 10);\r\n        result.iPhone = (ua.toLowerCase().includes('iphone'));\r\n        result.iPad = (ua.toLowerCase().includes('ipad'));\r\n    }\r\n    return result;\r\n}\n\nfunction IsMobileSafari() {\r\n    const { iOS } = IsiOS();\r\n    const mobileSafari = (navigator.userAgent.includes('AppleWebKit') && iOS);\r\n    return {\r\n        mobileSafari\r\n    };\r\n}\n\nfunction IsOpera() {\r\n    const opera = navigator.userAgent.includes('Opera');\r\n    return {\r\n        opera\r\n    };\r\n}\n\nfunction IsWindowsPhone() {\r\n    const ua = navigator.userAgent;\r\n    return ((/Windows Phone/i).test(ua) || (/IEMobile/i).test(ua));\r\n}\n\nfunction IsSafari() {\r\n    const ua = navigator.userAgent;\r\n    const safari = (ua.includes('Safari') && !IsWindowsPhone());\r\n    const safariVersion = ((/Version\\/(\\d+)\\./).test(ua)) ? parseInt(RegExp.$1, 10) : 0;\r\n    return {\r\n        safari,\r\n        safariVersion\r\n    };\r\n}\n\nfunction IsSilk() {\r\n    const silk = navigator.userAgent.includes('Silk');\r\n    return {\r\n        silk\r\n    };\r\n}\n\nfunction IsTrident() {\r\n    const trident = (/Trident\\/(\\d+\\.\\d+)(.*)rv:(\\d+\\.\\d+)/).test(navigator.userAgent);\r\n    const tridentVersion = (trident) ? parseInt(RegExp.$1, 10) : 0;\r\n    const tridentIEVersion = (trident) ? parseInt(RegExp.$3, 10) : 0;\r\n    return {\r\n        trident,\r\n        tridentVersion,\r\n        tridentIEVersion\r\n    };\r\n}\n\nfunction GetBrowser() {\r\n    const { chrome, chromeVersion } = IsChrome();\r\n    const { edge } = IsEdge();\r\n    const { firefox, firefoxVersion } = IsFirefox();\r\n    let { ie, ieVersion } = IsMSIE();\r\n    const { mobileSafari } = IsMobileSafari();\r\n    const { opera } = IsOpera();\r\n    const { safari, safariVersion } = IsSafari();\r\n    const { silk } = IsSilk();\r\n    const { trident, tridentVersion, tridentIEVersion } = IsTrident();\r\n    if (trident) {\r\n        ie = true;\r\n        ieVersion = tridentIEVersion;\r\n    }\r\n    const result = {\r\n        chrome,\r\n        chromeVersion,\r\n        edge,\r\n        firefox,\r\n        firefoxVersion,\r\n        ie,\r\n        ieVersion,\r\n        mobileSafari,\r\n        opera,\r\n        safari,\r\n        safariVersion,\r\n        silk,\r\n        trident,\r\n        tridentVersion\r\n    };\r\n    return result;\r\n}\n\nvar index$2 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    GetBrowser: GetBrowser,\n    IsChrome: IsChrome,\n    IsEdge: IsEdge,\n    IsFirefox: IsFirefox,\n    IsMobileSafari: IsMobileSafari,\n    IsMSIE: IsMSIE,\n    IsOpera: IsOpera,\n    IsSafari: IsSafari,\n    IsSilk: IsSilk,\n    IsTrident: IsTrident\n});\n\nfunction IsAndroid() {\r\n    return (navigator.userAgent.includes('Android'));\r\n}\n\nfunction IsChromeOS() {\r\n    return (navigator.userAgent.includes('CrOS'));\r\n}\n\nfunction IsCordova() {\r\n    return (window.hasOwnProperty('cordova'));\r\n}\n\nfunction IsCrosswalk() {\r\n    return (navigator.userAgent.includes('Crosswalk'));\r\n}\n\nfunction IsEjecta() {\r\n    return (window.hasOwnProperty('ejecta'));\r\n}\n\nfunction IsKindle() {\r\n    const ua = navigator.userAgent;\r\n    return ((ua.includes('Kindle') || (/\\bKF[A-Z][A-Z]+/).test(ua) || (/Silk.*Mobile Safari/).test(ua)));\r\n}\n\nfunction IsLinux() {\r\n    return (navigator.userAgent.includes('Linux'));\r\n}\n\nfunction IsMacOS() {\r\n    const ua = navigator.userAgent;\r\n    return (ua.includes('Mac OS') && !(ua.includes('like Mac OS')));\r\n}\n\nfunction IsNode() {\r\n    return (typeof process !== 'undefined' && typeof process.versions === 'object' && process.versions.hasOwnProperty('node'));\r\n}\n\nfunction IsNodeWebkit() {\r\n    return (IsNode() && !!process.versions.hasOwnProperty('node-webkit'));\r\n}\n\nfunction IsWebApp() {\r\n    return (navigator.hasOwnProperty('standalone'));\r\n}\n\nfunction IsWindows() {\r\n    return (navigator.userAgent.includes('Windows'));\r\n}\n\nfunction GetOS() {\r\n    const ua = navigator.userAgent;\r\n    const { iOS, iOSVersion, iPad, iPhone } = IsiOS();\r\n    const result = {\r\n        android: IsAndroid(),\r\n        chromeOS: IsChromeOS(),\r\n        cordova: IsCordova(),\r\n        crosswalk: IsCrosswalk(),\r\n        desktop: false,\r\n        ejecta: IsEjecta(),\r\n        iOS,\r\n        iOSVersion,\r\n        iPad,\r\n        iPhone,\r\n        kindle: IsKindle(),\r\n        linux: IsLinux(),\r\n        macOS: IsMacOS(),\r\n        node: IsNode(),\r\n        nodeWebkit: IsNodeWebkit(),\r\n        pixelRatio: 1,\r\n        webApp: IsWebApp(),\r\n        windows: IsWindows(),\r\n        windowsPhone: IsWindowsPhone()\r\n    };\r\n    if (result.windowsPhone) {\r\n        result.android = false;\r\n        result.iOS = false;\r\n        result.macOS = false;\r\n        result.windows = true;\r\n    }\r\n    const silk = ua.includes('Silk');\r\n    if (result.windows || result.macOS || (result.linux && !silk) || result.chromeOS) {\r\n        result.desktop = true;\r\n    }\r\n    if (result.windowsPhone || (((/Windows NT/i).test(ua)) && ((/Touch/i).test(ua)))) {\r\n        result.desktop = false;\r\n    }\r\n    return result;\r\n}\n\nvar index$3 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    GetOS: GetOS,\n    IsAndroid: IsAndroid,\n    IsChromeOS: IsChromeOS,\n    IsCordova: IsCordova,\n    IsCrosswalk: IsCrosswalk,\n    IsEjecta: IsEjecta,\n    IsiOS: IsiOS,\n    IsKindle: IsKindle,\n    IsLinux: IsLinux,\n    IsMacOS: IsMacOS,\n    IsNode: IsNode,\n    IsNodeWebkit: IsNodeWebkit,\n    IsWebApp: IsWebApp,\n    IsWindows: IsWindows,\n    IsWindowsPhone: IsWindowsPhone\n});\n\nlet _videoElement;\r\nfunction CanPlayVideoType(type, videoElement) {\r\n    if (!videoElement) {\r\n        if (!_videoElement) {\r\n            _videoElement = document.createElement('video');\r\n        }\r\n        videoElement = _videoElement;\r\n    }\r\n    return (videoElement && videoElement.canPlayType(type) !== '');\r\n}\n\nfunction CanPlayH264Video(videoElement) {\r\n    return CanPlayVideoType('video/mp4; codecs=\"avc1.42E01E\"', videoElement);\r\n}\n\nfunction CanPlayHLSVideo(videoElement) {\r\n    return CanPlayVideoType('application/x-mpegURL; codecs=\"avc1.42E01E\"', videoElement);\r\n}\n\nfunction CanPlayOGGVideo(videoElement) {\r\n    return CanPlayVideoType('video/ogg; codecs=\"theora\"', videoElement);\r\n}\n\nfunction CanPlayVP9Video(videoElement) {\r\n    return CanPlayVideoType('video/webm; codecs=\"vp9\"', videoElement);\r\n}\n\nfunction CanPlayWebMVideo(videoElement) {\r\n    return CanPlayVideoType('video/webm; codecs=\"vp8, vorbis\"', videoElement);\r\n}\n\nfunction GetVideo() {\r\n    return {\r\n        h264Video: CanPlayH264Video(),\r\n        hlsVideo: CanPlayHLSVideo(),\r\n        oggVideo: CanPlayOGGVideo(),\r\n        vp9Video: CanPlayVP9Video(),\r\n        webmVideo: CanPlayWebMVideo()\r\n    };\r\n}\n\nvar index$4 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    CanPlayH264Video: CanPlayH264Video,\n    CanPlayHLSVideo: CanPlayHLSVideo,\n    CanPlayOGGVideo: CanPlayOGGVideo,\n    CanPlayVP9Video: CanPlayVP9Video,\n    CanPlayVideoType: CanPlayVideoType,\n    CanPlayWebMVideo: CanPlayWebMVideo,\n    GetVideo: GetVideo\n});\n\nvar index$5 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Audio: index$1,\n    Browser: index$2,\n    OS: index$3,\n    Video: index$4,\n    CanPlayAudioType: CanPlayAudioType,\n    CanPlayM4A: CanPlayM4A,\n    CanPlayMP3: CanPlayMP3,\n    CanPlayOGG: CanPlayOGG,\n    CanPlayOpus: CanPlayOpus,\n    CanPlayWAV: CanPlayWAV,\n    CanPlayWebM: CanPlayWebM,\n    GetAudio: GetAudio,\n    HasAudio: HasAudio,\n    HasWebAudio: HasWebAudio,\n    GetBrowser: GetBrowser,\n    IsChrome: IsChrome,\n    IsEdge: IsEdge,\n    IsFirefox: IsFirefox,\n    IsMobileSafari: IsMobileSafari,\n    IsMSIE: IsMSIE,\n    IsOpera: IsOpera,\n    IsSafari: IsSafari,\n    IsSilk: IsSilk,\n    IsTrident: IsTrident,\n    GetOS: GetOS,\n    IsAndroid: IsAndroid,\n    IsChromeOS: IsChromeOS,\n    IsCordova: IsCordova,\n    IsCrosswalk: IsCrosswalk,\n    IsEjecta: IsEjecta,\n    IsiOS: IsiOS,\n    IsKindle: IsKindle,\n    IsLinux: IsLinux,\n    IsMacOS: IsMacOS,\n    IsNode: IsNode,\n    IsNodeWebkit: IsNodeWebkit,\n    IsWebApp: IsWebApp,\n    IsWindows: IsWindows,\n    IsWindowsPhone: IsWindowsPhone,\n    CanPlayH264Video: CanPlayH264Video,\n    CanPlayHLSVideo: CanPlayHLSVideo,\n    CanPlayOGGVideo: CanPlayOGGVideo,\n    CanPlayVP9Video: CanPlayVP9Video,\n    CanPlayVideoType: CanPlayVideoType,\n    CanPlayWebMVideo: CanPlayWebMVideo,\n    GetVideo: GetVideo\n});\n\nfunction ClearEvent(emitter, event) {\r\n    emitter.events.delete(event);\r\n    return emitter;\r\n}\n\nfunction Emit(emitter, event, ...args) {\r\n    if (!emitter.events.has(event)) {\r\n        return false;\r\n    }\r\n    const listeners = emitter.events.get(event);\r\n    for (const ee of listeners) {\r\n        ee.callback.apply(ee.context, args);\r\n        if (ee.once) {\r\n            listeners.delete(ee);\r\n        }\r\n    }\r\n    if (listeners.size === 0) {\r\n        emitter.events.delete(event);\r\n    }\r\n    return true;\r\n}\n\nclass EventEmitter {\r\n    constructor() {\r\n        this.events = new Map();\r\n    }\r\n}\n\nclass EventInstance {\r\n    constructor(callback, context, once = false) {\r\n        this.callback = callback;\r\n        this.context = context;\r\n        this.once = once;\r\n    }\r\n}\n\nfunction GetEventNames(emitter) {\r\n    return [...emitter.events.keys()];\r\n}\n\nfunction GetListenerCount(emitter, event) {\r\n    const listeners = emitter.events.get(event);\r\n    return (listeners) ? listeners.size : 0;\r\n}\n\nfunction GetListeners(emitter, event) {\r\n    const out = [];\r\n    const listeners = emitter.events.get(event);\r\n    listeners.forEach(listener => {\r\n        out.push(listener.callback);\r\n    });\r\n    return out;\r\n}\n\nfunction Off(emitter, event, callback, context, once) {\r\n    const events = emitter.events;\r\n    if (!callback) {\r\n        events.delete(event);\r\n    }\r\n    else {\r\n        const listeners = events.get(event);\r\n        const hasContext = !context;\r\n        const hasOnce = (once !== undefined);\r\n        for (const listener of listeners) {\r\n            if ((listener.callback === callback) &&\r\n                (hasContext && listener.context === console) &&\r\n                (hasOnce && listener.once === once)) {\r\n                listeners.delete(listener);\r\n            }\r\n        }\r\n        if (listeners.size === 0) {\r\n            events.delete(event);\r\n        }\r\n    }\r\n    return emitter;\r\n}\n\nfunction On(emitter, event, callback, context = emitter, once = false) {\r\n    if (typeof callback !== 'function') {\r\n        throw new TypeError('Listener not a function');\r\n    }\r\n    const listener = new EventInstance(callback, context, once);\r\n    const listeners = emitter.events.get(event);\r\n    if (!listeners) {\r\n        emitter.events.set(event, new Set([listener]));\r\n    }\r\n    else {\r\n        listeners.add(listener);\r\n    }\r\n    return emitter;\r\n}\n\nfunction Once(emitter, event, callback, context = emitter) {\r\n    return On(emitter, event, callback, context, true);\r\n}\n\nfunction RemoveAllListeners(emitter, event) {\r\n    if (!event) {\r\n        emitter.events.clear();\r\n    }\r\n    else {\r\n        emitter.events.delete(event);\r\n    }\r\n}\n\nvar index$6 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ClearEvent: ClearEvent,\n    Emit: Emit,\n    EventEmitter: EventEmitter,\n    EventInstance: EventInstance,\n    GetEventNames: GetEventNames,\n    GetListenerCount: GetListenerCount,\n    GetListeners: GetListeners,\n    Off: Off,\n    On: On,\n    Once: Once,\n    RemoveAllListeners: RemoveAllListeners\n});\n\nfunction GetChildIndex(parent, child) {\r\n    return parent.children.indexOf(child);\r\n}\n\nfunction RemoveChild(parent, child) {\r\n    const children = parent.children;\r\n    const currentIndex = GetChildIndex(parent, child);\r\n    if (currentIndex > -1) {\r\n        children.splice(currentIndex, 1);\r\n        child.parent = null;\r\n    }\r\n    return child;\r\n}\n\nfunction SetParent(parent, ...child) {\r\n    child.forEach(entity => {\r\n        if (entity.parent) {\r\n            RemoveChild(entity.parent, entity);\r\n        }\r\n        entity.world = parent.world;\r\n        entity.parent = parent;\r\n    });\r\n}\n\nfunction Copy(src, target) {\r\n    return target.set(src.a, src.b, src.c, src.d, src.tx, src.ty);\r\n}\n\nfunction UpdateWorldTransform(gameObject) {\r\n    gameObject.dirty.setRender();\r\n    const parent = gameObject.parent;\r\n    const transform = gameObject.transform;\r\n    const lt = transform.local;\r\n    const wt = transform.world;\r\n    lt.tx = transform.x;\r\n    lt.ty = transform.y;\r\n    if (!parent) {\r\n        Copy(lt, wt);\r\n        return;\r\n    }\r\n    const { a, b, c, d, tx, ty } = lt;\r\n    const { a: pa, b: pb, c: pc, d: pd, tx: ptx, ty: pty } = parent.transform.world;\r\n    wt.set(a * pa + b * pc, a * pb + b * pd, c * pa + d * pc, c * pb + d * pd, tx * pa + ty * pc + ptx, tx * pb + ty * pd + pty);\r\n}\n\nfunction AddChild(parent, child) {\r\n    SetParent(parent, child);\r\n    parent.children.push(child);\r\n    UpdateWorldTransform(child);\r\n    return child;\r\n}\n\nfunction AddChildAt(parent, index, child) {\r\n    const children = parent.children;\r\n    if (index >= 0 && index <= children.length) {\r\n        SetParent(parent, child);\r\n        children.splice(index, 0, child);\r\n        UpdateWorldTransform(child);\r\n    }\r\n    return child;\r\n}\n\nfunction AddChildren(parent, ...children) {\r\n    children.forEach(child => {\r\n        SetParent(parent, child);\r\n        parent.children.push(child);\r\n        UpdateWorldTransform(child);\r\n    });\r\n    return children;\r\n}\n\nfunction AddChildrenAt(parent, index, ...children) {\r\n    const parentChildren = parent.children;\r\n    if (index >= 0 && index <= parentChildren.length) {\r\n        children.reverse().forEach(child => {\r\n            SetParent(parent, child);\r\n            children.splice(index, 0, child);\r\n            UpdateWorldTransform(child);\r\n        });\r\n    }\r\n    return children;\r\n}\n\nfunction AddPosition(x, y, ...child) {\r\n    child.forEach(entity => {\r\n        entity.x += x;\r\n        entity.y += y;\r\n    });\r\n}\n\nfunction AddRotation(rotation, ...child) {\r\n    child.forEach(entity => {\r\n        entity.rotation += rotation;\r\n    });\r\n}\n\nfunction AddScale(scaleX, scaleY, ...child) {\r\n    child.forEach(entity => {\r\n        entity.scaleX += scaleX;\r\n        entity.scaleY += scaleY;\r\n    });\r\n}\n\nfunction AddSkew(skewX, skewY, ...child) {\r\n    child.forEach(entity => {\r\n        entity.skewX += skewX;\r\n        entity.skewY += skewY;\r\n    });\r\n}\n\nfunction Contains(rect, x, y) {\r\n    if (rect.width <= 0 || rect.height <= 0) {\r\n        return false;\r\n    }\r\n    return (rect.x <= x && rect.x + rect.width >= x && rect.y <= y && rect.y + rect.height >= y);\r\n}\n\nclass Rectangle {\r\n    constructor(x = 0, y = 0, width = 0, height = 0) {\r\n        this.set(x, y, width, height);\r\n    }\r\n    set(x = 0, y = 0, width = 0, height = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n    contains(x, y) {\r\n        return Contains(this, x, y);\r\n    }\r\n    set right(value) {\r\n        if (value <= this.x) {\r\n            this.width = 0;\r\n        }\r\n        else {\r\n            this.width = value - this.x;\r\n        }\r\n    }\r\n    get right() {\r\n        return this.x + this.width;\r\n    }\r\n    set bottom(value) {\r\n        if (value <= this.y) {\r\n            this.height = 0;\r\n        }\r\n        else {\r\n            this.height = value - this.y;\r\n        }\r\n    }\r\n    get bottom() {\r\n        return this.y + this.height;\r\n    }\r\n}\n\nclass BoundsComponent {\r\n    constructor(parent) {\r\n        this.fixed = false;\r\n        this.parent = parent;\r\n        this.area = new Rectangle();\r\n    }\r\n    setArea(x, y, width, height) {\r\n        this.area.set(x, y, width, height);\r\n    }\r\n    destroy() {\r\n        this.parent = null;\r\n        this.area = null;\r\n    }\r\n}\n\nlet instance;\r\nlet frame = 0;\r\nconst GameInstance = {\r\n    get: () => {\r\n        return instance;\r\n    },\r\n    set: (game) => {\r\n        instance = game;\r\n    },\r\n    getFrame: () => {\r\n        return frame;\r\n    },\r\n    setFrame: (current) => {\r\n        frame = current;\r\n    }\r\n};\n\nclass DirtyComponent {\r\n    constructor(parent) {\r\n        this.render = true;\r\n        this.update = true;\r\n        this.frame = 0;\r\n        this.parent = parent;\r\n    }\r\n    setRender() {\r\n        this.render = true;\r\n        this.frame = GameInstance.getFrame();\r\n    }\r\n    setUpdate() {\r\n        this.update = true;\r\n    }\r\n    destroy() {\r\n        this.parent = null;\r\n    }\r\n}\n\nclass InputComponent {\r\n    constructor(parent) {\r\n        this.enabled = false;\r\n        this.enabledChildren = true;\r\n        this.parent = parent;\r\n    }\r\n    destroy() {\r\n        this.parent = null;\r\n        this.hitArea = null;\r\n    }\r\n}\n\nclass Matrix2D {\r\n    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\r\n        this.set(a, b, c, d, tx, ty);\r\n    }\r\n    set(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\r\n        this.a = a;\r\n        this.b = b;\r\n        this.c = c;\r\n        this.d = d;\r\n        this.tx = tx;\r\n        this.ty = ty;\r\n        return this;\r\n    }\r\n    identity() {\r\n        return this.set();\r\n    }\r\n    toArray() {\r\n        return [this.a, this.b, this.c, this.d, this.tx, this.ty];\r\n    }\r\n    fromArray(src) {\r\n        return this.set(src[0], src[1], src[2], src[3], src[4], src[5]);\r\n    }\r\n}\n\nfunction UpdateLocalTransform(gameObject) {\r\n    const transformComponent = gameObject.transform;\r\n    const local = transformComponent.local;\r\n    const { rotation, skewX, skewY, scaleX, scaleY, x, y } = transformComponent;\r\n    local.set(Math.cos(rotation + skewY) * scaleX, Math.sin(rotation + skewY) * scaleX, -Math.sin(rotation - skewX) * scaleY, Math.cos(rotation - skewX) * scaleY, x, y);\r\n    UpdateWorldTransform(gameObject);\r\n}\n\nclass TransformComponent {\r\n    constructor(parent, x = 0, y = 0) {\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.rotation = 0;\r\n        this.scaleX = 1;\r\n        this.scaleY = 1;\r\n        this.skewX = 0;\r\n        this.skewY = 0;\r\n        this.originX = 0.5;\r\n        this.originY = 0.5;\r\n        this.width = 0;\r\n        this.height = 0;\r\n        this.parent = parent;\r\n        this.local = new Matrix2D();\r\n        this.world = new Matrix2D();\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    setSize(width, height) {\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n    setWidth(value) {\r\n        this.width = value;\r\n    }\r\n    setHeight(value) {\r\n        this.height = value;\r\n    }\r\n    setPosition(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n        UpdateWorldTransform(this.parent);\r\n    }\r\n    setX(value) {\r\n        this.x = value;\r\n        UpdateWorldTransform(this.parent);\r\n    }\r\n    setY(value) {\r\n        this.y = value;\r\n        UpdateWorldTransform(this.parent);\r\n    }\r\n    setOrigin(x, y) {\r\n        this.originX = x;\r\n        this.originY = y;\r\n    }\r\n    setOriginX(value) {\r\n        this.originX = value;\r\n    }\r\n    setOriginY(value) {\r\n        this.originX = value;\r\n    }\r\n    setSkew(x, y) {\r\n        this.skewX = x;\r\n        this.skewY = y;\r\n        UpdateLocalTransform(this.parent);\r\n    }\r\n    setSkewX(value) {\r\n        if (value !== this.skewX) {\r\n            this.skewX = value;\r\n            UpdateLocalTransform(this.parent);\r\n        }\r\n    }\r\n    setSkewY(value) {\r\n        if (value !== this.skewY) {\r\n            this.skewY = value;\r\n            UpdateLocalTransform(this.parent);\r\n        }\r\n    }\r\n    setScale(x, y) {\r\n        this.scaleX = x;\r\n        this.scaleY = y;\r\n        UpdateLocalTransform(this.parent);\r\n    }\r\n    setScaleX(value) {\r\n        if (value !== this.scaleX) {\r\n            this.scaleX = value;\r\n            UpdateLocalTransform(this.parent);\r\n        }\r\n    }\r\n    setScaleY(value) {\r\n        if (value !== this.scaleY) {\r\n            this.scaleY = value;\r\n            UpdateLocalTransform(this.parent);\r\n        }\r\n    }\r\n    setRotation(value) {\r\n        if (value !== this.rotation) {\r\n            this.rotation = value;\r\n            UpdateLocalTransform(this.parent);\r\n        }\r\n    }\r\n    destroy() {\r\n        this.parent = null;\r\n        this.local = null;\r\n        this.world = null;\r\n    }\r\n}\n\nfunction RemoveChildrenBetween(parent, beginIndex = 0, endIndex) {\r\n    const children = parent.children;\r\n    if (endIndex === undefined) {\r\n        endIndex = children.length;\r\n    }\r\n    const range = endIndex - beginIndex;\r\n    if (range > 0 && range <= endIndex) {\r\n        const removed = children.splice(beginIndex, range);\r\n        removed.forEach(child => {\r\n            child.parent = null;\r\n        });\r\n        return removed;\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n}\n\nfunction DestroyChildren(parent, beginIndex = 0, endIndex) {\r\n    const removed = RemoveChildrenBetween(parent, beginIndex, endIndex);\r\n    removed.forEach(child => {\r\n        child.destroy();\r\n    });\r\n}\n\nfunction ReparentChildren(parent, newParent, beginIndex = 0, endIndex) {\r\n    const moved = RemoveChildrenBetween(parent, beginIndex, endIndex);\r\n    moved.forEach(child => {\r\n        SetParent(newParent, child);\r\n    });\r\n    return moved;\r\n}\n\nclass GameObject {\r\n    constructor(x = 0, y = 0) {\r\n        this.name = '';\r\n        this.type = 'GameObject';\r\n        this.willRender = true;\r\n        this.willUpdate = true;\r\n        this.visible = true;\r\n        this.children = [];\r\n        this.dirty = new DirtyComponent(this);\r\n        this.transform = new TransformComponent(this, x, y);\r\n        this.bounds = new BoundsComponent(this);\r\n        this.input = new InputComponent(this);\r\n    }\r\n    isRenderable() {\r\n        return (this.visible && this.willRender);\r\n    }\r\n    update(delta, time) {\r\n        if (this.willUpdate) {\r\n            const children = this.children;\r\n            for (let i = 0; i < children.length; i++) {\r\n                const child = children[i];\r\n                if (child && child.willUpdate) {\r\n                    child.update(delta, time);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    get numChildren() {\r\n        return this.children.length;\r\n    }\r\n    set width(value) {\r\n        this.transform.setWidth(value);\r\n    }\r\n    get width() {\r\n        return this.transform.width;\r\n    }\r\n    set height(value) {\r\n        this.transform.setHeight(value);\r\n    }\r\n    get height() {\r\n        return this.transform.height;\r\n    }\r\n    set x(value) {\r\n        this.transform.setX(value);\r\n    }\r\n    get x() {\r\n        return this.transform.x;\r\n    }\r\n    set y(value) {\r\n        this.transform.setY(value);\r\n    }\r\n    get y() {\r\n        return this.transform.y;\r\n    }\r\n    set originX(value) {\r\n        this.transform.setOriginX(value);\r\n    }\r\n    get originX() {\r\n        return this.transform.originX;\r\n    }\r\n    set originY(value) {\r\n        this.transform.setOriginY(value);\r\n    }\r\n    get originY() {\r\n        return this.transform.originY;\r\n    }\r\n    set skewX(value) {\r\n        this.transform.setSkewX(value);\r\n    }\r\n    get skewX() {\r\n        return this.transform.skewX;\r\n    }\r\n    set skewY(value) {\r\n        this.transform.setSkewY(value);\r\n    }\r\n    get skewY() {\r\n        return this.transform.skewY;\r\n    }\r\n    set scaleX(value) {\r\n        this.transform.setScaleX(value);\r\n    }\r\n    get scaleX() {\r\n        return this.transform.scaleX;\r\n    }\r\n    set scaleY(value) {\r\n        this.transform.setScaleY(value);\r\n    }\r\n    get scaleY() {\r\n        return this.transform.scaleY;\r\n    }\r\n    set rotation(value) {\r\n        this.transform.setRotation(value);\r\n    }\r\n    get rotation() {\r\n        return this.transform.rotation;\r\n    }\r\n    destroy(reparentChildren) {\r\n        if (reparentChildren) {\r\n            ReparentChildren(this, reparentChildren);\r\n        }\r\n        else {\r\n            DestroyChildren(this);\r\n        }\r\n        this.transform.destroy();\r\n        this.dirty.destroy();\r\n        this.bounds.destroy();\r\n        this.input.destroy();\r\n        this.world = null;\r\n        this.parent = null;\r\n        this.children = null;\r\n    }\r\n}\n\nclass Container extends GameObject {\r\n    constructor(x = 0, y = 0) {\r\n        super(x, y);\r\n        this._alpha = 1;\r\n        this.type = 'Container';\r\n    }\r\n    get alpha() {\r\n        return this._alpha;\r\n    }\r\n    set alpha(value) {\r\n        if (value !== this._alpha) {\r\n            this._alpha = value;\r\n        }\r\n    }\r\n}\n\nfunction SetFrame(texture, key, ...sprite) {\r\n    const frame = texture.get(key);\r\n    sprite.forEach(entity => {\r\n        if (frame === entity.frame) {\r\n            return;\r\n        }\r\n        entity.frame = frame;\r\n        entity.transform.setSize(frame.sourceSizeWidth, frame.sourceSizeHeight);\r\n        entity.bounds.setArea(entity.x, entity.y, entity.width, entity.height);\r\n        const pivot = frame.pivot;\r\n        if (pivot) {\r\n            entity.transform.setOrigin(pivot.x, pivot.y);\r\n        }\r\n        const data = entity.vertexData;\r\n        data[2] = frame.u0;\r\n        data[3] = frame.v0;\r\n        data[8] = frame.u0;\r\n        data[9] = frame.v1;\r\n        data[14] = frame.u1;\r\n        data[15] = frame.v1;\r\n        data[20] = frame.u1;\r\n        data[21] = frame.v0;\r\n        entity.dirty.setRender();\r\n        entity.hasTexture = true;\r\n    });\r\n}\n\nlet gl;\r\nconst GL = {\r\n    get: () => {\r\n        return gl;\r\n    },\r\n    set: (context) => {\r\n        gl = context;\r\n    }\r\n};\n\nfunction IsSizePowerOfTwo(width, height) {\r\n    if (width < 1 || height < 1) {\r\n        return false;\r\n    }\r\n    return ((width & (width - 1)) === 0) && ((height & (height - 1)) === 0);\r\n}\n\nfunction CreateGLTexture(source, width, height, potClamp = true, linear = true) {\r\n    const gl = GL.get();\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    const glTexture = gl.createTexture();\r\n    gl.activeTexture(gl.TEXTURE0);\r\n    gl.bindTexture(gl.TEXTURE_2D, glTexture);\r\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\r\n    if (source) {\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);\r\n        width = source.width;\r\n        height = source.height;\r\n    }\r\n    else {\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n    }\r\n    const mode = (linear) ? gl.LINEAR : gl.NEAREST;\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, mode);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, mode);\r\n    const pot = (source && IsSizePowerOfTwo(width, height));\r\n    const wrap = (pot && potClamp) ? gl.REPEAT : gl.CLAMP_TO_EDGE;\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrap);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrap);\r\n    if (pot) {\r\n        gl.generateMipmap(gl.TEXTURE_2D);\r\n    }\r\n    return glTexture;\r\n}\n\nfunction DeleteFramebuffer(framebuffer) {\r\n    const gl = GL.get();\r\n    if (gl.isFramebuffer(framebuffer)) {\r\n        gl.deleteFramebuffer(framebuffer);\r\n    }\r\n}\n\nfunction DeleteGLTexture(texture) {\r\n    const gl = GL.get();\r\n    if (!gl) {\r\n        return;\r\n    }\r\n    if (gl.isTexture(texture)) {\r\n        gl.deleteTexture(texture);\r\n    }\r\n}\n\nclass Frame {\r\n    constructor(texture, key, x, y, width, height) {\r\n        this.trimmed = false;\r\n        this.texture = texture;\r\n        this.key = key;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n        this.sourceSizeWidth = width;\r\n        this.sourceSizeHeight = height;\r\n        this.updateUVs();\r\n    }\r\n    setPivot(x, y) {\r\n        this.pivot = { x, y };\r\n    }\r\n    setSize(width, height) {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.sourceSizeWidth = width;\r\n        this.sourceSizeHeight = height;\r\n        this.updateUVs();\r\n    }\r\n    setSourceSize(width, height) {\r\n        this.sourceSizeWidth = width;\r\n        this.sourceSizeHeight = height;\r\n    }\r\n    setTrim(width, height, x, y, w, h) {\r\n        this.trimmed = true;\r\n        this.sourceSizeWidth = width;\r\n        this.sourceSizeHeight = height;\r\n        this.spriteSourceSizeX = x;\r\n        this.spriteSourceSizeY = y;\r\n        this.spriteSourceSizeWidth = w;\r\n        this.spriteSourceSizeHeight = h;\r\n    }\r\n    updateUVs() {\r\n        const { x, y, width, height } = this;\r\n        const baseTextureWidth = this.texture.width;\r\n        const baseTextureHeight = this.texture.height;\r\n        this.u0 = x / baseTextureWidth;\r\n        this.v0 = y / baseTextureHeight;\r\n        this.u1 = (x + width) / baseTextureWidth;\r\n        this.v1 = (y + height) / baseTextureHeight;\r\n    }\r\n}\n\nfunction SetGLTextureFilterMode(texture, linear = true) {\r\n    const gl = GL.get();\r\n    gl.activeTexture(gl.TEXTURE0);\r\n    gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    const mode = (linear) ? gl.LINEAR : gl.NEAREST;\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, mode);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, mode);\r\n}\n\nfunction UpdateGLTexture(source, dstTexture, flipY = false) {\r\n    const gl = GL.get();\r\n    const width = source.width;\r\n    const height = source.height;\r\n    if (width > 0 && height > 0) {\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, dstTexture);\r\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);\r\n    }\r\n}\n\nclass Texture {\r\n    constructor(image, width, height) {\r\n        this.key = '';\r\n        this.glIndex = 0;\r\n        this.glIndexCounter = -1;\r\n        if (image) {\r\n            width = image.width;\r\n            height = image.height;\r\n        }\r\n        this.image = image;\r\n        this.width = width;\r\n        this.height = height;\r\n        this.frames = new Map();\r\n        this.data = {};\r\n        this.add('__BASE', 0, 0, width, height);\r\n    }\r\n    add(key, x, y, width, height) {\r\n        if (this.frames.has(key)) {\r\n            return null;\r\n        }\r\n        const frame = new Frame(this, key, x, y, width, height);\r\n        this.frames.set(key, frame);\r\n        if (!this.firstFrame || this.firstFrame.key === '__BASE') {\r\n            this.firstFrame = frame;\r\n        }\r\n        return frame;\r\n    }\r\n    get(key) {\r\n        if (!key) {\r\n            return this.firstFrame;\r\n        }\r\n        if (key instanceof Frame) {\r\n            key = key.key;\r\n        }\r\n        let frame = this.frames.get(key);\r\n        if (!frame) {\r\n            console.warn('Texture.frame missing: ' + key);\r\n            frame = this.firstFrame;\r\n        }\r\n        return frame;\r\n    }\r\n    getFrames(frames) {\r\n        const output = [];\r\n        frames.forEach((key) => {\r\n            output.push(this.get(key));\r\n        });\r\n        return output;\r\n    }\r\n    getFramesInRange(prefix, start, end, zeroPad = 0, suffix = '') {\r\n        const frameKeys = [];\r\n        const diff = (start < end) ? 1 : -1;\r\n        end += diff;\r\n        for (let i = start; i !== end; i += diff) {\r\n            frameKeys.push(prefix + i.toString().padStart(zeroPad, '0') + suffix);\r\n        }\r\n        return this.getFrames(frameKeys);\r\n    }\r\n    setSize(width, height) {\r\n        this.width = width;\r\n        this.height = height;\r\n        const frame = this.frames.get('__BASE');\r\n        frame.setSize(width, height);\r\n    }\r\n    setFilter(linear) {\r\n        SetGLTextureFilterMode(this.glTexture, linear);\r\n    }\r\n    createGL() {\r\n        if (this.glTexture) {\r\n            DeleteGLTexture(this.glTexture);\r\n        }\r\n        this.glTexture = CreateGLTexture(this.image);\r\n    }\r\n    updateGL() {\r\n        if (!this.glTexture) {\r\n            this.glTexture = CreateGLTexture(this.image);\r\n        }\r\n        else {\r\n            UpdateGLTexture(this.image, this.glTexture);\r\n        }\r\n    }\r\n    destroy() {\r\n        this.frames.clear();\r\n        this.image = null;\r\n        this.firstFrame = null;\r\n        this.data = null;\r\n        DeleteGLTexture(this.glTexture);\r\n        DeleteFramebuffer(this.glFramebuffer);\r\n    }\r\n}\n\nlet instance$1;\r\nconst TextureManagerInstance = {\r\n    get: () => {\r\n        return instance$1;\r\n    },\r\n    set: (manager) => {\r\n        instance$1 = manager;\r\n    }\r\n};\n\nfunction SetTexture(key, frame, ...sprite) {\r\n    if (!key) {\r\n        return;\r\n    }\r\n    let texture;\r\n    if (key instanceof Texture) {\r\n        texture = key;\r\n    }\r\n    else {\r\n        texture = TextureManagerInstance.get().get(key);\r\n    }\r\n    if (!texture) {\r\n        console.warn('Invalid Texture key: ' + key);\r\n        return;\r\n    }\r\n    else {\r\n        if (!texture.glTexture) {\r\n            texture.createGL();\r\n        }\r\n        sprite.forEach(entity => {\r\n            entity.texture = texture;\r\n            SetFrame(texture, frame, entity);\r\n        });\r\n    }\r\n}\n\nclass Sprite extends Container {\r\n    constructor(x, y, texture, frame) {\r\n        super(x, y);\r\n        this.hasTexture = false;\r\n        this.prevTextureID = -1;\r\n        this._tint = 0xffffff;\r\n        this.vertexData = new Float32Array(24).fill(0);\r\n        this.vertexColor = new Uint32Array(4).fill(4294967295);\r\n        this.vertexAlpha = new Float32Array(4).fill(1);\r\n        this.vertexTint = new Uint32Array(4).fill(0xffffff);\r\n        this.type = 'Sprite';\r\n        this.setTexture(texture, frame);\r\n        this.bounds.setArea(x, y, this.width, this.height);\r\n    }\r\n    setTexture(key, frame) {\r\n        SetTexture(key, frame, this);\r\n        return this;\r\n    }\r\n    setFrame(key) {\r\n        SetFrame(this.texture, key, this);\r\n        return this;\r\n    }\r\n    isRenderable() {\r\n        return (this.visible && this.willRender && this.hasTexture && this.alpha > 0);\r\n    }\r\n    updateVertices() {\r\n        const data = this.vertexData;\r\n        this.dirty.render = false;\r\n        const frame = this.frame;\r\n        const originX = this.originX;\r\n        const originY = this.originY;\r\n        let w0;\r\n        let w1;\r\n        let h0;\r\n        let h1;\r\n        const { a, b, c, d, tx, ty } = this.transform.world;\r\n        if (frame.trimmed) {\r\n            w1 = frame.spriteSourceSizeX - (originX * frame.sourceSizeWidth);\r\n            w0 = w1 + frame.spriteSourceSizeWidth;\r\n            h1 = frame.spriteSourceSizeY - (originY * frame.sourceSizeHeight);\r\n            h0 = h1 + frame.spriteSourceSizeHeight;\r\n        }\r\n        else {\r\n            w1 = -originX * frame.sourceSizeWidth;\r\n            w0 = w1 + frame.sourceSizeWidth;\r\n            h1 = -originY * frame.sourceSizeHeight;\r\n            h0 = h1 + frame.sourceSizeHeight;\r\n        }\r\n        const x0 = (w1 * a) + (h1 * c) + tx;\r\n        const y0 = (w1 * b) + (h1 * d) + ty;\r\n        const x1 = (w1 * a) + (h0 * c) + tx;\r\n        const y1 = (w1 * b) + (h0 * d) + ty;\r\n        const x2 = (w0 * a) + (h0 * c) + tx;\r\n        const y2 = (w0 * b) + (h0 * d) + ty;\r\n        const x3 = (w0 * a) + (h1 * c) + tx;\r\n        const y3 = (w0 * b) + (h1 * d) + ty;\r\n        data[0] = x0;\r\n        data[1] = y0;\r\n        data[6] = x1;\r\n        data[7] = y1;\r\n        data[12] = x2;\r\n        data[13] = y2;\r\n        data[18] = x3;\r\n        data[19] = y3;\r\n        const boundsX = Math.min(x0, x1, x2, x3);\r\n        const boundsY = Math.min(y0, y1, y2, y3);\r\n        const boundsRight = Math.max(x0, x1, x2, x3);\r\n        const boundsBottom = Math.max(y0, y1, y2, y3);\r\n        this.bounds.setArea(boundsX, boundsY, boundsRight, boundsBottom);\r\n    }\r\n    get tint() {\r\n        return this._tint;\r\n    }\r\n    set tint(value) {\r\n        this._tint = value;\r\n    }\r\n    destroy(reparentChildren) {\r\n        super.destroy(reparentChildren);\r\n        this.texture = null;\r\n        this.frame = null;\r\n        this.hasTexture = false;\r\n        this.vertexData = null;\r\n        this.vertexColor = null;\r\n        this.vertexAlpha = null;\r\n        this.vertexTint = null;\r\n    }\r\n}\n\nclass AnimatedSprite extends Sprite {\r\n    constructor(x, y, texture, frame) {\r\n        super(x, y, texture, frame);\r\n        this.type = 'AnimatedSprite';\r\n        this.anims = new Map();\r\n        this.animData = {\r\n            currentAnim: '',\r\n            currentFrames: [],\r\n            frameIndex: 0,\r\n            animSpeed: 0,\r\n            nextFrameTime: 0,\r\n            repeatCount: 0,\r\n            isPlaying: false,\r\n            yoyo: false,\r\n            pendingStart: false,\r\n            playingForward: true,\r\n            delay: 0,\r\n            repeatDelay: 0,\r\n            onStart: null,\r\n            onRepeat: null,\r\n            onComplete: null\r\n        };\r\n    }\r\n    stop() {\r\n        const data = this.animData;\r\n        data.isPlaying = false;\r\n        data.currentAnim = '';\r\n        if (data.onComplete) {\r\n            data.onComplete(this, data.currentAnim);\r\n        }\r\n    }\r\n    nextFrame() {\r\n        const data = this.animData;\r\n        data.frameIndex++;\r\n        if (data.frameIndex === data.currentFrames.length) {\r\n            if (data.yoyo) {\r\n                data.frameIndex--;\r\n                data.playingForward = false;\r\n            }\r\n            else if (data.repeatCount === -1 || data.repeatCount > 0) {\r\n                data.frameIndex = 0;\r\n                if (data.repeatCount !== -1) {\r\n                    data.repeatCount--;\r\n                }\r\n                if (data.onRepeat) {\r\n                    data.onRepeat(this, data.currentAnim);\r\n                }\r\n                data.nextFrameTime += data.repeatDelay;\r\n            }\r\n            else {\r\n                data.frameIndex--;\r\n                return this.stop();\r\n            }\r\n        }\r\n        this.setFrame(data.currentFrames[data.frameIndex]);\r\n        data.nextFrameTime += data.animSpeed;\r\n    }\r\n    prevFrame() {\r\n        const data = this.animData;\r\n        data.frameIndex--;\r\n        if (data.frameIndex === -1) {\r\n            if (data.repeatCount === -1 || data.repeatCount > 0) {\r\n                data.frameIndex = 0;\r\n                data.playingForward = true;\r\n                if (data.repeatCount !== -1) {\r\n                    data.repeatCount--;\r\n                }\r\n                if (data.onRepeat) {\r\n                    data.onRepeat(this, data.currentAnim);\r\n                }\r\n                data.nextFrameTime += data.repeatDelay;\r\n            }\r\n            else {\r\n                data.frameIndex = 0;\r\n                return this.stop();\r\n            }\r\n        }\r\n        this.setFrame(data.currentFrames[data.frameIndex]);\r\n        data.nextFrameTime += data.animSpeed;\r\n    }\r\n    update(delta, now) {\r\n        super.update(delta, now);\r\n        const data = this.animData;\r\n        if (!data.isPlaying) {\r\n            return;\r\n        }\r\n        data.nextFrameTime -= delta * 1000;\r\n        data.nextFrameTime = Math.max(data.nextFrameTime, 0);\r\n        if (data.nextFrameTime === 0) {\r\n            if (data.pendingStart) {\r\n                if (data.onStart) {\r\n                    data.onStart(this, data.currentAnim);\r\n                }\r\n                data.pendingStart = false;\r\n                data.nextFrameTime = data.animSpeed;\r\n            }\r\n            else if (data.playingForward) {\r\n                this.nextFrame();\r\n            }\r\n            else {\r\n                this.prevFrame();\r\n            }\r\n        }\r\n    }\r\n    get isPlaying() {\r\n        return this.animData.isPlaying;\r\n    }\r\n    get isPlayingForward() {\r\n        return (this.animData.isPlaying && this.animData.playingForward);\r\n    }\r\n    get currentAnimation() {\r\n        return this.animData.currentAnim;\r\n    }\r\n    destroy(reparentChildren) {\r\n        super.destroy(reparentChildren);\r\n        this.anims.clear();\r\n        this.animData = null;\r\n    }\r\n}\n\nfunction BringChildToTop(parent, child) {\r\n    const parentChildren = parent.children;\r\n    const currentIndex = GetChildIndex(parent, child);\r\n    if (currentIndex !== -1 && currentIndex < parentChildren.length) {\r\n        parentChildren.splice(currentIndex, 1);\r\n        parentChildren.push(child);\r\n        child.dirty.setRender();\r\n    }\r\n    return child;\r\n}\n\nfunction CountMatchingChildren(parent, property, value) {\r\n    const children = parent.children;\r\n    let total = 0;\r\n    children.forEach(child => {\r\n        const descriptor = Object.getOwnPropertyDescriptor(child, property);\r\n        if (descriptor && (value === undefined || value === descriptor.value)) {\r\n            total++;\r\n        }\r\n    });\r\n    return total;\r\n}\n\nfunction GetChildAt(parent, index) {\r\n    const children = parent.children;\r\n    if (index < 0 || index > children.length) {\r\n        throw new Error('Index out of bounds: ' + index);\r\n    }\r\n    return children[index];\r\n}\n\nfunction GetChildren(parent, property, value) {\r\n    const children = parent.children;\r\n    if (!property) {\r\n        return [...children];\r\n    }\r\n    const results = [];\r\n    children.forEach(child => {\r\n        const descriptor = Object.getOwnPropertyDescriptor(child, property);\r\n        if (descriptor && (value === undefined || value === descriptor.value)) {\r\n            results.push(child);\r\n        }\r\n    });\r\n    return results;\r\n}\n\nfunction GetFirstChild(parent, property, value) {\r\n    const children = parent.children;\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        const descriptor = Object.getOwnPropertyDescriptor(child, property);\r\n        if (descriptor && (value === undefined || value === descriptor.value)) {\r\n            return child;\r\n        }\r\n    }\r\n}\n\nfunction GetLastChild(parent, property, value) {\r\n    const children = parent.children;\r\n    for (let i = children.length - 1; i >= 0; i--) {\r\n        const child = children[i];\r\n        const descriptor = Object.getOwnPropertyDescriptor(child, property);\r\n        if (descriptor && (value === undefined || value === descriptor.value)) {\r\n            return child;\r\n        }\r\n    }\r\n}\n\nfunction GetRandomChild(parent, startIndex = 0, length) {\r\n    const children = parent.children;\r\n    if (!length) {\r\n        length = children.length;\r\n    }\r\n    const randomIndex = startIndex + Math.floor(Math.random() * length);\r\n    return children[randomIndex];\r\n}\n\nfunction MoveChildDown(parent, child) {\r\n    const parentChildren = parent.children;\r\n    const currentIndex = GetChildIndex(parent, child);\r\n    if (currentIndex > 0) {\r\n        const child2 = parentChildren[currentIndex - 1];\r\n        const index2 = parentChildren.indexOf(child2);\r\n        parentChildren[currentIndex] = child2;\r\n        parentChildren[index2] = child;\r\n        child.dirty.setRender();\r\n        child2.dirty.setRender();\r\n    }\r\n    return child;\r\n}\n\nfunction MoveChildTo(parent, child, index) {\r\n    const parentChildren = parent.children;\r\n    const currentIndex = GetChildIndex(parent, child);\r\n    if (currentIndex === -1 || index < 0 || index >= parentChildren.length) {\r\n        throw new Error('Index out of bounds');\r\n    }\r\n    if (currentIndex !== index) {\r\n        parentChildren.splice(currentIndex, 1);\r\n        parentChildren.splice(index, 0, child);\r\n        child.dirty.setRender();\r\n    }\r\n    return child;\r\n}\n\nfunction MoveChildUp(parent, child) {\r\n    const parentChildren = parent.children;\r\n    const currentIndex = GetChildIndex(parent, child);\r\n    if (currentIndex !== -1 && currentIndex > 0) {\r\n        const child2 = parentChildren[currentIndex + 1];\r\n        const index2 = parentChildren.indexOf(child2);\r\n        parentChildren[currentIndex] = child2;\r\n        parentChildren[index2] = child;\r\n        child.dirty.setRender();\r\n        child2.dirty.setRender();\r\n    }\r\n    return child;\r\n}\n\nfunction NOOP() {\r\n}\n\nfunction AddTimer(world, config) {\r\n    const { duration = 0, repeat = 0, delay = -1, onStart = NOOP, onUpdate = NOOP, onRepeat = NOOP, onComplete = NOOP } = config;\r\n    const timer = {\r\n        elapsed: duration,\r\n        duration,\r\n        repeat,\r\n        delay,\r\n        update: null,\r\n        onStart,\r\n        onUpdate,\r\n        onRepeat,\r\n        onComplete\r\n    };\r\n    timer.update = (delta) => {\r\n        if (timer.delay > 0) {\r\n            timer.delay -= delta;\r\n            if (timer.delay < 0) {\r\n                timer.delay = 0;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        if (timer.delay === 0) {\r\n            timer.onStart();\r\n            timer.delay = -1;\r\n        }\r\n        if (timer.delay === -1) {\r\n            timer.elapsed -= delta;\r\n            timer.onUpdate(delta, timer.elapsed / timer.duration);\r\n            if (timer.elapsed <= 0) {\r\n                if (timer.repeat > 0) {\r\n                    timer.repeat--;\r\n                    timer.elapsed = timer.duration;\r\n                    timer.onRepeat(timer.repeat);\r\n                }\r\n                else {\r\n                    timer.elapsed = 0;\r\n                    timer.onComplete();\r\n                }\r\n            }\r\n        }\r\n        return (timer.elapsed === 0);\r\n    };\r\n    world.clock.events.add(timer);\r\n}\n\nfunction AngleBetween(x1, y1, x2, y2) {\r\n    return Math.atan2(y2 - y1, x2 - x1);\r\n}\n\nfunction AngleBetweenPoints(point1, point2) {\r\n    return Math.atan2(point2.y - point1.y, point2.x - point1.x);\r\n}\n\nfunction AngleBetweenPointsY(point1, point2) {\r\n    return Math.atan2(point2.x - point1.x, point2.y - point1.y);\r\n}\n\nfunction AngleBetweenY(x1, y1, x2, y2) {\r\n    return Math.atan2(x2 - x1, y2 - y1);\r\n}\n\nconst MATH_CONST = {\r\n    PI2: Math.PI * 2,\r\n    HALF_PI: Math.PI * 0.5,\r\n    EPSILON: 1.0e-6,\r\n    DEG_TO_RAD: Math.PI / 180,\r\n    RAD_TO_DEG: 180 / Math.PI,\r\n    MIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER || -9007199254740991,\r\n    MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991\r\n};\n\nfunction CounterClockwise(angle) {\r\n    if (angle > Math.PI) {\r\n        angle -= MATH_CONST.PI2;\r\n    }\r\n    return Math.abs((((angle + MATH_CONST.HALF_PI) % MATH_CONST.PI2) - MATH_CONST.PI2) % MATH_CONST.PI2);\r\n}\n\nfunction NormalizeAngle(angle) {\r\n    angle = angle % MATH_CONST.PI2;\r\n    if (angle >= 0) {\r\n        return angle;\r\n    }\r\n    else {\r\n        return angle + MATH_CONST.PI2;\r\n    }\r\n}\n\nfunction ReverseAngle(angle) {\r\n    return NormalizeAngle(angle + Math.PI);\r\n}\n\nfunction RotateAngleTo(currentAngle, targetAngle, lerp = 0.05) {\r\n    if (currentAngle === targetAngle) {\r\n        return currentAngle;\r\n    }\r\n    if (Math.abs(targetAngle - currentAngle) <= lerp || Math.abs(targetAngle - currentAngle) >= (MATH_CONST.PI2 - lerp)) {\r\n        currentAngle = targetAngle;\r\n    }\r\n    else {\r\n        if (Math.abs(targetAngle - currentAngle) > Math.PI) {\r\n            if (targetAngle < currentAngle) {\r\n                targetAngle += MATH_CONST.PI2;\r\n            }\r\n            else {\r\n                targetAngle -= MATH_CONST.PI2;\r\n            }\r\n        }\r\n        if (targetAngle > currentAngle) {\r\n            currentAngle += lerp;\r\n        }\r\n        else if (targetAngle < currentAngle) {\r\n            currentAngle -= lerp;\r\n        }\r\n    }\r\n    return currentAngle;\r\n}\n\nfunction ShortestAngleBetween(angle1, angle2) {\r\n    const difference = angle2 - angle1;\r\n    if (difference === 0) {\r\n        return 0;\r\n    }\r\n    const times = Math.floor((difference - (-180)) / 360);\r\n    return difference - (times * 360);\r\n}\n\nfunction Wrap(value, min, max) {\r\n    const range = max - min;\r\n    return (min + ((((value - min) % range) + range) % range));\r\n}\n\nfunction WrapAngle(angle) {\r\n    return Wrap(angle, -Math.PI, Math.PI);\r\n}\n\nfunction WrapAngleDegrees(angle) {\r\n    return Wrap(angle, -180, 180);\r\n}\n\nvar index$7 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    AngleBetween: AngleBetween,\n    AngleBetweenPoints: AngleBetweenPoints,\n    AngleBetweenPointsY: AngleBetweenPointsY,\n    AngleBetweenY: AngleBetweenY,\n    CounterClockwise: CounterClockwise,\n    NormalizeAngle: NormalizeAngle,\n    ReverseAngle: ReverseAngle,\n    RotateAngleTo: RotateAngleTo,\n    ShortestAngleBetween: ShortestAngleBetween,\n    WrapAngle: WrapAngle,\n    WrapAngleDegrees: WrapAngleDegrees\n});\n\nfunction ChebyshevDistance(x1, y1, x2, y2) {\r\n    return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));\r\n}\n\nfunction DistanceBetween(x1, y1, x2, y2) {\r\n    const dx = x1 - x2;\r\n    const dy = y1 - y2;\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n}\n\nfunction DistanceBetweenPoints(a, b) {\r\n    const dx = a.x - b.x;\r\n    const dy = a.y - b.y;\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n}\n\nfunction DistanceBetweenPointsSquared(a, b) {\r\n    const dx = a.x - b.x;\r\n    const dy = a.y - b.y;\r\n    return dx * dx + dy * dy;\r\n}\n\nfunction DistancePower(x1, y1, x2, y2, pow = 2) {\r\n    return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));\r\n}\n\nfunction DistanceSquared(x1, y1, x2, y2) {\r\n    const dx = x1 - x2;\r\n    const dy = y1 - y2;\r\n    return dx * dx + dy * dy;\r\n}\n\nfunction SnakeDistance(x1, y1, x2, y2) {\r\n    return Math.abs(x1 - x2) + Math.abs(y1 - y2);\r\n}\n\nvar index$8 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ChebyshevDistance: ChebyshevDistance,\n    DistanceBetween: DistanceBetween,\n    DistanceBetweenPoints: DistanceBetweenPoints,\n    DistanceBetweenPointsSquared: DistanceBetweenPointsSquared,\n    DistancePower: DistancePower,\n    DistanceSquared: DistanceSquared,\n    SnakeDistance: SnakeDistance\n});\n\nfunction MoveToPosition(x, y, duration, ...child) {\r\n    child.forEach(entity => {\r\n        const px = entity.x;\r\n        const py = entity.y;\r\n        const azimuth = AngleBetween(px, py, x, y);\r\n        const speed = DistanceBetween(px, py, x, y) / (duration / 1000);\r\n        const incX = Math.cos(azimuth) * speed;\r\n        const incY = Math.sin(azimuth) * speed;\r\n        const moveHandler = (delta) => {\r\n            delta /= 1000;\r\n            entity.x += incX * delta;\r\n            entity.y += incY * delta;\r\n        };\r\n        const world = entity.world;\r\n        if (world) {\r\n            AddTimer(world, {\r\n                duration,\r\n                onUpdate: moveHandler\r\n            });\r\n        }\r\n    });\r\n}\n\nfunction RemoveChildAt(parent, index) {\r\n    const children = parent.children;\r\n    let child;\r\n    if (index >= 0 && index < children.length) {\r\n        const removed = children.splice(index, 1);\r\n        if (removed[0]) {\r\n            child = removed[0];\r\n            child.parent = null;\r\n        }\r\n    }\r\n    return child;\r\n}\n\nfunction RemoveChildren(parent, ...children) {\r\n    children.forEach(child => {\r\n        RemoveChild(parent, child);\r\n    });\r\n}\n\nfunction RemoveChildrenAt(parent, ...index) {\r\n    const children = parent.children;\r\n    const removed = [];\r\n    index.sort((a, b) => a - b);\r\n    index.reverse().forEach(entity => {\r\n        const child = GetChildAt(parent, entity);\r\n        if (child) {\r\n            children.splice(entity, 1);\r\n            child.parent = null;\r\n            removed.push(child);\r\n        }\r\n    });\r\n    return removed;\r\n}\n\nfunction RotateChildrenLeft(parent, total = 1) {\r\n    const parentChildren = parent.children;\r\n    let child = null;\r\n    for (let i = 0; i < total; i++) {\r\n        child = parentChildren.shift();\r\n        parentChildren.push(child);\r\n        child.dirty.setRender();\r\n    }\r\n    return child;\r\n}\n\nfunction RotateChildrenRight(parent, total = 1) {\r\n    const parentChildren = parent.children;\r\n    let child = null;\r\n    for (let i = 0; i < total; i++) {\r\n        child = parentChildren.pop();\r\n        parentChildren.unshift(child);\r\n        child.dirty.setRender();\r\n    }\r\n    return child;\r\n}\n\nfunction SendChildToBack(parent, child) {\r\n    const parentChildren = parent.children;\r\n    const currentIndex = GetChildIndex(parent, child);\r\n    if (currentIndex !== -1 && currentIndex > 0) {\r\n        parentChildren.splice(currentIndex, 1);\r\n        parentChildren.unshift(child);\r\n        child.dirty.setRender();\r\n    }\r\n    return child;\r\n}\n\nfunction SetBounds(x, y, width, height, ...child) {\r\n    child.forEach(entity => {\r\n        entity.bounds.setArea(x, y, width, height);\r\n    });\r\n}\n\nfunction SetName(name, ...child) {\r\n    child.forEach(entity => {\r\n        entity.name = name;\r\n    });\r\n}\n\nfunction SetOrigin(originX, originY, ...child) {\r\n    child.forEach(entity => {\r\n        entity.transform.setOrigin(originX, originY);\r\n    });\r\n}\n\nfunction SetPosition(x, y, ...child) {\r\n    child.forEach(entity => {\r\n        entity.transform.setPosition(x, y);\r\n    });\r\n}\n\nfunction SetRotation(rotation, ...child) {\r\n    child.forEach(entity => {\r\n        entity.rotation = rotation;\r\n    });\r\n}\n\nfunction SetScale(scaleX, scaleY, ...child) {\r\n    child.forEach(entity => {\r\n        entity.transform.setScale(scaleX, scaleY);\r\n    });\r\n}\n\nfunction SetSize(width, height, ...child) {\r\n    child.forEach(entity => {\r\n        entity.transform.setSize(width, height);\r\n    });\r\n}\n\nfunction SetSkew(skewX, skewY, ...child) {\r\n    child.forEach(entity => {\r\n        entity.transform.setSkew(skewX, skewY);\r\n    });\r\n}\n\nfunction SetType(type, ...child) {\r\n    child.forEach(entity => {\r\n        entity.type = type;\r\n    });\r\n}\n\nfunction SetVisible(visible, ...child) {\r\n    child.forEach(entity => {\r\n        entity.visible = visible;\r\n    });\r\n}\n\nfunction SetWorld(world, ...child) {\r\n    child.forEach(entity => {\r\n        entity.world = world;\r\n    });\r\n}\n\nfunction ShuffleChildren(parent) {\r\n    const children = parent.children;\r\n    for (let i = children.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        const temp = children[i];\r\n        children[i] = children[j];\r\n        children[j] = temp;\r\n        temp.dirty.setRender();\r\n    }\r\n    return children;\r\n}\n\nfunction SwapChildren(child1, child2) {\r\n    if (child1.parent === child2.parent) {\r\n        const children = child1.parent.children;\r\n        const index1 = GetChildIndex(child1.parent, child1);\r\n        const index2 = GetChildIndex(child2.parent, child2);\r\n        if (index1 !== index2) {\r\n            children[index1] = child2;\r\n            children[index2] = child1;\r\n        }\r\n    }\r\n}\n\nfunction CreateCanvas(width, height) {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    return canvas.getContext('2d');\r\n}\n\nfunction CanvasTexture(width = 32, height = 32) {\r\n    const ctx = CreateCanvas(width, height);\r\n    return new Texture(ctx.canvas);\r\n}\n\nclass Text extends Sprite {\r\n    constructor(x, y, text = '', font, fillStyle) {\r\n        super(x, y, CanvasTexture());\r\n        this.splitRegExp = /(?:\\r\\n|\\r|\\n)/;\r\n        this.padding = { left: 0, right: 0, top: 0, bottom: 0 };\r\n        this.verticalAlign = 'ascent';\r\n        this.lineSpacing = 0;\r\n        this.font = '16px monospace';\r\n        this.fillStyle = '#fff';\r\n        this.strokeStyle = '';\r\n        this.backgroundStyle = '';\r\n        this.cornerRadius = 0;\r\n        this.textAlign = 'left';\r\n        this.textBaseline = 'alphabetic';\r\n        this.lineWidth = 0;\r\n        this.lineDash = [];\r\n        this.antialias = false;\r\n        this.type = 'Text';\r\n        const game = GameInstance.get();\r\n        this.resolution = game.renderer.resolution;\r\n        this.canvas = this.texture.image;\r\n        this.context = this.canvas.getContext('2d');\r\n        this.texture.glTexture = CreateGLTexture(this.canvas, 32, 32, false, this.antialias);\r\n        if (font) {\r\n            this.font = font;\r\n        }\r\n        if (fillStyle) {\r\n            this.fillStyle = fillStyle;\r\n        }\r\n        this.setText(text);\r\n    }\r\n    syncContext(canvas, ctx) {\r\n        if (this.preRenderCallback) {\r\n            this.preRenderCallback(canvas, ctx);\r\n        }\r\n        ctx.font = this.font;\r\n        ctx.textBaseline = this.textBaseline;\r\n        ctx.textAlign = this.textAlign;\r\n        ctx.fillStyle = this.fillStyle;\r\n        ctx.strokeStyle = this.strokeStyle;\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.lineCap = 'round';\r\n        ctx.lineJoin = 'round';\r\n        ctx.setLineDash(this.lineDash);\r\n        ctx.imageSmoothingEnabled = this.antialias;\r\n    }\r\n    updateText() {\r\n        const canvas = this.canvas;\r\n        const ctx = this.context;\r\n        const resolution = this.resolution;\r\n        const lines = this._text.split(this.splitRegExp);\r\n        const padding = this.padding;\r\n        const fillStyle = this.fillStyle;\r\n        const strokeStyle = this.strokeStyle;\r\n        const strokeWidth = this.lineWidth;\r\n        const lineSpacing = this.lineSpacing;\r\n        const strokeWidthHalf = (strokeWidth > 0) ? strokeWidth / 2 : 0;\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n        this.syncContext(canvas, ctx);\r\n        ctx.textAlign = 'start';\r\n        let maxWidth = 0;\r\n        let maxHeight = 0;\r\n        let y = 0;\r\n        const lineMetrics = [];\r\n        const vAlignAscent = (this.verticalAlign === 'ascent');\r\n        const metrics = ctx.measureText('|MÉq');\r\n        const averageLineHeight = Math.ceil(Math.abs(metrics.actualBoundingBoxAscent) + Math.abs(metrics.actualBoundingBoxDescent)) + strokeWidth;\r\n        for (let i = 0; i < lines.length; i++) {\r\n            const metrics = ctx.measureText(lines[i]);\r\n            const left = metrics.actualBoundingBoxLeft;\r\n            const right = metrics.actualBoundingBoxRight;\r\n            let ascent = metrics.actualBoundingBoxAscent;\r\n            let descent = metrics.actualBoundingBoxDescent;\r\n            if ((!ascent && !descent) || lines[i] === '') {\r\n                ascent = averageLineHeight;\r\n                descent = 0;\r\n            }\r\n            const lineWidth = Math.ceil(Math.abs(left) + Math.abs(right)) + strokeWidth;\r\n            const lineHeight = Math.ceil(Math.abs(ascent) + Math.abs(descent)) + strokeWidth;\r\n            if (vAlignAscent) {\r\n                y += ascent + strokeWidthHalf;\r\n                if (i > 0) {\r\n                    y += lineSpacing + strokeWidthHalf;\r\n                }\r\n                maxHeight = y + descent + strokeWidthHalf;\r\n            }\r\n            else {\r\n                y = maxHeight + ((lineHeight - descent) - strokeWidthHalf);\r\n                maxHeight += lineHeight;\r\n                if (i < lines.length - 1) {\r\n                    maxHeight += lineSpacing;\r\n                }\r\n            }\r\n            maxWidth = Math.max(maxWidth, lineWidth);\r\n            lineMetrics.push({ lineWidth, lineHeight, ascent, descent, left, right, y });\r\n        }\r\n        maxWidth += padding.left + padding.right;\r\n        maxHeight += padding.top + padding.bottom;\r\n        const displayWidth = (this.fixedWidth) ? this.fixedWidth : maxWidth;\r\n        const displayHeight = (this.fixedHeight) ? this.fixedHeight : maxHeight;\r\n        const canvasWidth = Math.ceil(displayWidth * resolution);\r\n        const canvasHeight = Math.ceil(displayHeight * resolution);\r\n        if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\r\n            canvas.width = canvasWidth;\r\n            canvas.height = canvasHeight;\r\n            this.texture.setSize(displayWidth, displayHeight);\r\n            this.transform.setSize(displayWidth, displayHeight);\r\n        }\r\n        ctx.save();\r\n        ctx.scale(resolution, resolution);\r\n        this.syncContext(canvas, ctx);\r\n        const backgroundStyle = this.backgroundStyle;\r\n        if (backgroundStyle) {\r\n            ctx.save();\r\n            ctx.fillStyle = backgroundStyle;\r\n            ctx.strokeStyle = backgroundStyle;\r\n            const cornerRadius = this.cornerRadius;\r\n            const halfRadius = (cornerRadius > 0) ? cornerRadius / 2 : 0;\r\n            if (cornerRadius) {\r\n                ctx.lineWidth = cornerRadius;\r\n                ctx.strokeRect(halfRadius, halfRadius, displayWidth - cornerRadius, displayHeight - cornerRadius);\r\n            }\r\n            ctx.fillRect(halfRadius, halfRadius, displayWidth - cornerRadius, displayHeight - cornerRadius);\r\n            ctx.restore();\r\n        }\r\n        const textAlign = this.textAlign;\r\n        const isCenter = (textAlign === 'center');\r\n        const isRight = (textAlign === 'right' || textAlign === 'end');\r\n        const yOffset = ((displayHeight - maxHeight) / 2) + padding.top;\r\n        for (let i = 0; i < lines.length; i++) {\r\n            const line = lines[i];\r\n            const metrics = lineMetrics[i];\r\n            let tx = padding.left + metrics.left + strokeWidthHalf;\r\n            const ty = yOffset + metrics.y;\r\n            if (isCenter) {\r\n                tx = displayWidth / 2;\r\n            }\r\n            else if (isRight) {\r\n                tx = displayWidth - strokeWidthHalf;\r\n            }\r\n            if (strokeStyle) {\r\n                ctx.strokeText(line, tx, ty);\r\n            }\r\n            if (fillStyle) {\r\n                ctx.fillText(line, tx, ty);\r\n            }\r\n        }\r\n        ctx.restore();\r\n        this.texture.updateGL();\r\n        this.dirty.setRender();\r\n        return this;\r\n    }\r\n    get text() {\r\n        return this._text;\r\n    }\r\n    set text(value) {\r\n        this.setText(value);\r\n    }\r\n    setText(value = '') {\r\n        if (Array.isArray(value)) {\r\n            value = value.join('\\n');\r\n        }\r\n        if (value !== this._text) {\r\n            this._text = value.toString();\r\n            this.updateText();\r\n        }\r\n        return this;\r\n    }\r\n    destroy(reparentChildren) {\r\n        this.texture.destroy();\r\n        this.fillStyle = null;\r\n        this.strokeStyle = null;\r\n        this.backgroundStyle = null;\r\n        this.canvas = null;\r\n        this.context = null;\r\n        super.destroy(reparentChildren);\r\n    }\r\n}\n\nvar index$9 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    AddChild: AddChild,\n    AddChildAt: AddChildAt,\n    AddChildren: AddChildren,\n    AddChildrenAt: AddChildrenAt,\n    AddPosition: AddPosition,\n    AddRotation: AddRotation,\n    AddScale: AddScale,\n    AddSkew: AddSkew,\n    AnimatedSprite: AnimatedSprite,\n    BringChildToTop: BringChildToTop,\n    Container: Container,\n    CountMatchingChildren: CountMatchingChildren,\n    DestroyChildren: DestroyChildren,\n    GameObject: GameObject,\n    GetChildAt: GetChildAt,\n    GetChildIndex: GetChildIndex,\n    GetChildren: GetChildren,\n    GetFirstChild: GetFirstChild,\n    GetLastChild: GetLastChild,\n    GetRandomChild: GetRandomChild,\n    MoveChildDown: MoveChildDown,\n    MoveChildTo: MoveChildTo,\n    MoveChildUp: MoveChildUp,\n    MoveToPosition: MoveToPosition,\n    RemoveChild: RemoveChild,\n    RemoveChildAt: RemoveChildAt,\n    RemoveChildren: RemoveChildren,\n    RemoveChildrenAt: RemoveChildrenAt,\n    RemoveChildrenBetween: RemoveChildrenBetween,\n    ReparentChildren: ReparentChildren,\n    RotateChildrenLeft: RotateChildrenLeft,\n    RotateChildrenRight: RotateChildrenRight,\n    SendChildToBack: SendChildToBack,\n    SetBounds: SetBounds,\n    SetName: SetName,\n    SetOrigin: SetOrigin,\n    SetParent: SetParent,\n    SetPosition: SetPosition,\n    SetRotation: SetRotation,\n    SetScale: SetScale,\n    SetSize: SetSize,\n    SetSkew: SetSkew,\n    SetType: SetType,\n    SetVisible: SetVisible,\n    SetWorld: SetWorld,\n    ShuffleChildren: ShuffleChildren,\n    Sprite: Sprite,\n    SwapChildren: SwapChildren,\n    Text: Text\n});\n\nfunction FuzzyCeil(value, epsilon = 0.0001) {\r\n    return Math.ceil(value - epsilon);\r\n}\n\nfunction FuzzyEqual(a, b, epsilon = 0.0001) {\r\n    return Math.abs(a - b) < epsilon;\r\n}\n\nfunction FuzzyFloor(value, epsilon = 0.0001) {\r\n    return Math.floor(value + epsilon);\r\n}\n\nfunction FuzzyGreaterThan(a, b, epsilon = 0.0001) {\r\n    return a > b - epsilon;\r\n}\n\nfunction FuzzyLessThan(a, b, epsilon = 0.0001) {\r\n    return a < b + epsilon;\r\n}\n\nvar index$a = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    FuzzyCeil: FuzzyCeil,\n    FuzzyEqual: FuzzyEqual,\n    FuzzyFloor: FuzzyFloor,\n    FuzzyGreaterThan: FuzzyGreaterThan,\n    FuzzyLessThan: FuzzyLessThan\n});\n\nfunction Factorial(value) {\r\n    if (value === 0) {\r\n        return 1;\r\n    }\r\n    let res = value;\r\n    while (--value) {\r\n        res *= value;\r\n    }\r\n    return res;\r\n}\n\nfunction Bernstein(n, i) {\r\n    return Factorial(n) / Factorial(i) / Factorial(n - i);\r\n}\n\nfunction BezierInterpolation(v, k) {\r\n    let b = 0;\r\n    const n = v.length - 1;\r\n    for (let i = 0; i <= n; i++) {\r\n        b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * Bernstein(n, i);\r\n    }\r\n    return b;\r\n}\n\nfunction CatmullRom(t, p0, p1, p2, p3) {\r\n    const v0 = (p2 - p0) * 0.5;\r\n    const v1 = (p3 - p1) * 0.5;\r\n    const t2 = t * t;\r\n    const t3 = t * t2;\r\n    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\r\n}\n\nfunction CatmullRomInterpolation(v, k) {\r\n    const m = v.length - 1;\r\n    let f = m * k;\r\n    let i = Math.floor(f);\r\n    if (v[0] === v[m]) {\r\n        if (k < 0) {\r\n            i = Math.floor(f = m * (1 + k));\r\n        }\r\n        return CatmullRom(f - i, v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m]);\r\n    }\r\n    else {\r\n        if (k < 0) {\r\n            return v[0] - (CatmullRom(-f, v[0], v[0], v[1], v[1]) - v[0]);\r\n        }\r\n        if (k > 1) {\r\n            return v[m] - (CatmullRom(f - m, v[m], v[m], v[m - 1], v[m - 1]) - v[m]);\r\n        }\r\n        return CatmullRom(f - i, v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2]);\r\n    }\r\n}\n\nfunction P0(t, p) {\r\n    const k = 1 - t;\r\n    return k * k * k * p;\r\n}\r\nfunction P1(t, p) {\r\n    const k = 1 - t;\r\n    return 3 * k * k * t * p;\r\n}\r\nfunction P2(t, p) {\r\n    return 3 * (1 - t) * t * t * p;\r\n}\r\nfunction P3(t, p) {\r\n    return t * t * t * p;\r\n}\r\nfunction CubicBezierInterpolation(t, p0, p1, p2, p3) {\r\n    return P0(t, p0) + P1(t, p1) + P2(t, p2) + P3(t, p3);\r\n}\n\nfunction Linear(p0, p1, t) {\r\n    return (p1 - p0) * t + p0;\r\n}\n\nfunction LinearInterpolation(v, k) {\r\n    const m = v.length - 1;\r\n    const f = m * k;\r\n    const i = Math.floor(f);\r\n    if (k < 0) {\r\n        return Linear(v[0], v[1], f);\r\n    }\r\n    else if (k > 1) {\r\n        return Linear(v[m], v[m - 1], m - f);\r\n    }\r\n    else {\r\n        return Linear(v[i], v[(i + 1 > m) ? m : i + 1], f - i);\r\n    }\r\n}\n\nfunction P0$1(t, p) {\r\n    const k = 1 - t;\r\n    return k * k * p;\r\n}\r\nfunction P1$1(t, p) {\r\n    return 2 * (1 - t) * t * p;\r\n}\r\nfunction P2$1(t, p) {\r\n    return t * t * p;\r\n}\r\nfunction QuadraticBezierInterpolation(t, p0, p1, p2) {\r\n    return P0$1(t, p0) + P1$1(t, p1) + P2$1(t, p2);\r\n}\n\nfunction SmoothStep(x, min, max) {\r\n    if (x <= min) {\r\n        return 0;\r\n    }\r\n    if (x >= max) {\r\n        return 1;\r\n    }\r\n    x = (x - min) / (max - min);\r\n    return x * x * (3 - 2 * x);\r\n}\n\nfunction SmoothStepInterpolation(t, min, max) {\r\n    return min + (max - min) * SmoothStep(t, 0, 1);\r\n}\n\nfunction SmootherStep(x, min, max) {\r\n    x = Math.max(0, Math.min(1, (x - min) / (max - min)));\r\n    return x * x * x * (x * (x * 6 - 15) + 10);\r\n}\n\nfunction SmootherStepInterpolation(t, min, max) {\r\n    return min + (max - min) * SmootherStep(t, 0, 1);\r\n}\n\nvar index$b = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    BezierInterpolation: BezierInterpolation,\n    CatmullRomInterpolation: CatmullRomInterpolation,\n    CubicBezierInterpolation: CubicBezierInterpolation,\n    LinearInterpolation: LinearInterpolation,\n    QuadraticBezierInterpolation: QuadraticBezierInterpolation,\n    SmoothStepInterpolation: SmoothStepInterpolation,\n    SmootherStepInterpolation: SmootherStepInterpolation\n});\n\nfunction Add(target, src) {\r\n    target.a += src.a;\r\n    target.b += src.b;\r\n    target.c += src.c;\r\n    target.d += src.d;\r\n    target.tx += src.tx;\r\n    target.ty += src.ty;\r\n    return target;\r\n}\n\nfunction CopyToContext(src, context) {\r\n    const { a, b, c, d, tx, ty } = src;\r\n    context.transform(a, b, c, d, tx, ty);\r\n    return context;\r\n}\n\nfunction Determinant(src) {\r\n    const { a, b, c, d } = src;\r\n    return (a * d) - (b * c);\r\n}\n\nfunction Frobenius(src) {\r\n    return (Math.hypot(src.a, src.b, src.c, src.d, src.tx, src.ty, 1));\r\n}\n\nclass Vec2 {\r\n    constructor(x = 0, y = 0) {\r\n        this.set(x, y);\r\n    }\r\n    set(x = 0, y = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n    getArray() {\r\n        return [this.x, this.y];\r\n    }\r\n    fromArray(src) {\r\n        return this.set(src[0], src[1]);\r\n    }\r\n}\n\nfunction GlobalToLocal(mat, x, y, outPoint = new Vec2()) {\r\n    const { a, b, c, d, tx, ty } = mat;\r\n    const id = 1 / ((a * d) + (c * -b));\r\n    outPoint.x = (d * id * x) + (-c * id * y) + (((ty * c) - (tx * d)) * id);\r\n    outPoint.y = (a * id * y) + (-b * id * x) + (((-ty * a) + (tx * b)) * id);\r\n    return outPoint;\r\n}\n\nfunction ITRS(target, x, y, angle, scaleX, scaleY) {\r\n    if (angle === 0) {\r\n        return target.set(1, 0, 0, 1, x, y);\r\n    }\r\n    else {\r\n        const sin = Math.sin(angle);\r\n        const cos = Math.cos(angle);\r\n        return target.set(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, x, y);\r\n    }\r\n}\n\nfunction ITRSS(target, x, y, angle = 0, scaleX = 1, scaleY = 1, skewX = 0, skewY = 0) {\r\n    if (angle === 0) {\r\n        return target.set(1, 0, 0, 1, x, y);\r\n    }\r\n    else {\r\n        return target.set(Math.cos(angle + skewY) * scaleX, Math.sin(angle + skewY) * scaleX, -Math.sin(angle - skewX) * scaleY, Math.cos(angle - skewX) * scaleY, x, y);\r\n    }\r\n}\n\nfunction Invert(target) {\r\n    const { a, b, c, d, tx, ty } = target;\r\n    let determinant = a * d - b * c;\r\n    if (determinant) {\r\n        determinant = 1 / determinant;\r\n        target.set(d * determinant, -b * determinant, -c * determinant, a * determinant, (c * ty - d * tx) * determinant, (b * tx - a * ty) * determinant);\r\n    }\r\n    return target;\r\n}\n\nfunction LocalToGlobal(mat, x, y, outPoint = new Vec2()) {\r\n    const { a, b, c, d, tx, ty } = mat;\r\n    outPoint.x = (a * x) + (c * y) + tx;\r\n    outPoint.y = (b * x) + (d * y) + ty;\r\n    return outPoint;\r\n}\n\nfunction Multiply(target, src) {\r\n    const { a: a0, b: b0, c: c0, d: d0, tx: tx0, ty: ty0 } = target;\r\n    const { a: a1, b: b1, c: c1, d: d1, tx: tx1, ty: ty1 } = src;\r\n    target.a = a0 * a1 + c0 * b1;\r\n    target.b = b0 * a1 + d0 * b1;\r\n    target.c = a0 * c1 + c0 * d1;\r\n    target.d = b0 * c1 + d0 * d1;\r\n    target.tx = a0 * tx1 + c0 * ty1 + tx0;\r\n    target.ty = b0 * tx1 + d0 * ty1 + ty0;\r\n    return target;\r\n}\n\nfunction MultiplyScalar(target, scale) {\r\n    target.a *= scale;\r\n    target.b *= scale;\r\n    target.c *= scale;\r\n    target.d *= scale;\r\n    target.tx *= scale;\r\n    target.ty *= scale;\r\n    return target;\r\n}\n\nfunction MultiplyScalarAndAdd(target, src, scale) {\r\n    const { a, b, c, d, tx, ty } = src;\r\n    target.a += (a * scale);\r\n    target.b += (b * scale);\r\n    target.c += (c * scale);\r\n    target.d += (d * scale);\r\n    target.tx += (tx * scale);\r\n    target.ty += (ty * scale);\r\n    return target;\r\n}\n\nfunction Rotate(target, angle) {\r\n    const { a, b, c, d, tx, ty } = target;\r\n    const sin = Math.sin(angle);\r\n    const cos = Math.cos(angle);\r\n    return target.set((a * cos) + (c * sin), (b * cos) + (d * sin), (a * -sin) + (c * cos), (b * -sin) + (d * cos), tx, ty);\r\n}\n\nfunction Scale(target, scaleX, scaleY) {\r\n    target.a *= scaleX;\r\n    target.b *= scaleX;\r\n    target.c *= scaleY;\r\n    target.d *= scaleY;\r\n    return target;\r\n}\n\nfunction SetToContext(src, context) {\r\n    const { a, b, c, d, tx, ty } = src;\r\n    context.setTransform(a, b, c, d, tx, ty);\r\n    return context;\r\n}\n\nfunction Skew(target, angleX, angleY) {\r\n    target.b += Math.tan(angleX);\r\n    target.c += Math.tan(angleY);\r\n    return target;\r\n}\n\nfunction Subtract(target, src) {\r\n    const { a, b, c, d, tx, ty } = src;\r\n    target.a -= a;\r\n    target.b -= b;\r\n    target.c -= c;\r\n    target.d -= d;\r\n    target.tx -= tx;\r\n    target.ty -= ty;\r\n    return target;\r\n}\n\nfunction Translate(target, x, y) {\r\n    const { a, b, c, d, tx, ty } = target;\r\n    target.tx = (a * x) + (c * y) + tx;\r\n    target.ty = (b * x) + (d * y) + ty;\r\n    return target;\r\n}\n\nfunction Zero(target) {\r\n    return target.set(0, 0, 0, 0, 0, 0);\r\n}\n\nvar index$c = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Add: Add,\n    Copy: Copy,\n    CopyToContext: CopyToContext,\n    Determinant: Determinant,\n    Frobenius: Frobenius,\n    GlobalToLocal: GlobalToLocal,\n    Invert: Invert,\n    ITRS: ITRS,\n    ITRSS: ITRSS,\n    LocalToGlobal: LocalToGlobal,\n    Matrix2D: Matrix2D,\n    Multiply: Multiply,\n    MultiplyScalar: MultiplyScalar,\n    MultiplyScalarAndAdd: MultiplyScalarAndAdd,\n    Rotate: Rotate,\n    Scale: Scale,\n    SetToContext: SetToContext,\n    Skew: Skew,\n    Subtract: Subtract,\n    Translate: Translate,\n    Zero: Zero\n});\n\nfunction Add$1(a, b) {\r\n    return new Matrix2D(a.a + b.a, a.b + b.b, a.c + b.c, a.c + b.c, a.tx + b.tx, a.ty + b.ty);\r\n}\n\nfunction Append(mat1, mat2, out = new Matrix2D()) {\r\n    const { a: a1, b: b1, c: c1, d: d1, tx: tx1, ty: ty1 } = mat1;\r\n    const { a: a2, b: b2, c: c2, d: d2, tx: tx2, ty: ty2 } = mat2;\r\n    return out.set((a2 * a1) + (b2 * c1), (a2 * b1) + (b2 * d1), (c2 * a1) + (d2 * c1), (c2 * b1) + (d2 * d1), (tx2 * a1) + (ty2 * c1) + tx1, (tx2 * b1) + (ty2 * d1) + ty1);\r\n}\n\nfunction Clone(src) {\r\n    return new Matrix2D(src.a, src.b, src.c, src.d, src.tx, src.ty);\r\n}\n\nfunction Equals(a, b, epsilon = 0.000001) {\r\n    const { a: a0, b: b0, c: c0, d: d0, tx: tx0, ty: ty0 } = a;\r\n    const { a: a1, b: b1, c: c1, d: d1, tx: tx1, ty: ty1 } = b;\r\n    return (Math.abs(a0 - a1) <= epsilon * Math.max(1, Math.abs(a0), Math.abs(a1)) &&\r\n        Math.abs(b0 - b1) <= epsilon * Math.max(1, Math.abs(b0), Math.abs(b1)) &&\r\n        Math.abs(c0 - c1) <= epsilon * Math.max(1, Math.abs(c0), Math.abs(c1)) &&\r\n        Math.abs(d0 - d1) <= epsilon * Math.max(1, Math.abs(d0), Math.abs(d1)) &&\r\n        Math.abs(tx0 - tx1) <= epsilon * Math.max(1, Math.abs(tx0), Math.abs(tx1)) &&\r\n        Math.abs(ty0 - ty1) <= epsilon * Math.max(1, Math.abs(ty0), Math.abs(ty1)));\r\n}\n\nfunction ExactEquals(a, b) {\r\n    return (a.a === b.a &&\r\n        a.b === b.b &&\r\n        a.c === b.c &&\r\n        a.d === b.d &&\r\n        a.tx === b.tx &&\r\n        a.ty === b.ty);\r\n}\n\nfunction Rotate$1(src, angle) {\r\n    const { a, b, c, d } = src;\r\n    const sin = Math.sin(angle);\r\n    const cos = Math.cos(angle);\r\n    return new Matrix2D(a * cos + c * sin, b * cos + d * sin, a * -sin + c * cos, b * -sin + d * cos);\r\n}\n\nfunction FromRotation(angle) {\r\n    return Rotate$1(new Matrix2D(), angle);\r\n}\n\nfunction Scale$1(src, scaleX, scaleY) {\r\n    return new Matrix2D(src.a * scaleX, src.b * scaleX, src.c * scaleY, src.d * scaleY);\r\n}\n\nfunction FromScaling(scaleX, scaleY = scaleX) {\r\n    return Scale$1(new Matrix2D(), scaleX, scaleY);\r\n}\n\nfunction Translate$1(src, x, y) {\r\n    const { a, b, c, d, tx, ty } = src;\r\n    const dtx = a * x + c * y + tx;\r\n    const dty = b * x + d * y + ty;\r\n    return new Matrix2D(1, 0, 0, 1, dtx, dty);\r\n}\n\nfunction FromTranslation(x, y) {\r\n    return Translate$1(new Matrix2D(), x, y);\r\n}\n\nfunction Identity() {\r\n    return new Matrix2D();\r\n}\n\nfunction Invert$1(src) {\r\n    const { a, b, c, d, tx, ty } = src;\r\n    let determinant = (a * d) - (b * c);\r\n    if (!determinant) {\r\n        return null;\r\n    }\r\n    determinant = 1 / determinant;\r\n    return new Matrix2D(d * determinant, -b * determinant, -c * determinant, a * determinant, (c * ty - d * tx) * determinant, (b * tx - a * ty) * determinant);\r\n}\n\nfunction Multiply$1(a, b) {\r\n    const { a: a0, b: b0, c: c0, d: d0, tx: tx0, ty: ty0 } = a;\r\n    const { a: a1, b: b1, c: c1, d: d1, tx: tx1, ty: ty1 } = b;\r\n    return new Matrix2D(a0 * a1 + c0 * b1, b0 * a1 + d0 * b1, a0 * c1 + c0 * d1, b0 * c1 + d0 * d1, a0 * tx1 + c0 * ty1 + tx0, b0 * tx1 + d0 * ty1 + ty0);\r\n}\n\nfunction MultiplyScalar$1(src, scale) {\r\n    return new Matrix2D(src.a * scale, src.b * scale, src.c * scale, src.d * scale, src.tx * scale, src.ty * scale);\r\n}\n\nfunction MultiplyScalarAndAdd$1(a, b, scale) {\r\n    return new Matrix2D(a.a + (b.a * scale), a.b + (b.b * scale), a.c + (b.c * scale), a.d + (b.d * scale), a.tx + (b.tx * scale), a.ty + (b.ty * scale));\r\n}\n\nfunction Subtract$1(a, b) {\r\n    return new Matrix2D(a.a - b.a, a.b - b.b, a.c - b.c, a.c - b.c, a.tx - b.tx, a.ty - b.ty);\r\n}\n\nfunction Zero$1() {\r\n    return new Matrix2D(0, 0, 0, 0, 0, 0);\r\n}\n\nvar index$d = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Add: Add$1,\n    Append: Append,\n    Clone: Clone,\n    Equals: Equals,\n    ExactEquals: ExactEquals,\n    FromRotation: FromRotation,\n    FromScaling: FromScaling,\n    FromTranslation: FromTranslation,\n    Identity: Identity,\n    Invert: Invert$1,\n    Multiply: Multiply$1,\n    MultiplyScalar: MultiplyScalar$1,\n    MultiplyScalarAndAdd: MultiplyScalarAndAdd$1,\n    Rotate: Rotate$1,\n    Scale: Scale$1,\n    Subtract: Subtract$1,\n    Translate: Translate$1,\n    Zero: Zero$1\n});\n\nfunction GetPowerOfTwo(value) {\r\n    const index = Math.log(value) / 0.6931471805599453;\r\n    return (1 << Math.ceil(index));\r\n}\n\nfunction IsValuePowerOfTwo(value) {\r\n    return (value > 0 && (value & (value - 1)) === 0);\r\n}\n\nvar index$e = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    GetPowerOfTwo: GetPowerOfTwo,\n    IsSizePowerOfTwo: IsSizePowerOfTwo,\n    IsValuePowerOfTwo: IsValuePowerOfTwo\n});\n\nfunction SnapCeil(value, gap, start = 0, divide = false) {\r\n    if (gap === 0) {\r\n        return value;\r\n    }\r\n    value -= start;\r\n    value = gap * Math.ceil(value / gap);\r\n    return (divide) ? (start + value) / gap : start + value;\r\n}\n\nfunction SnapFloor(value, gap, start = 0, divide = false) {\r\n    if (gap === 0) {\r\n        return value;\r\n    }\r\n    value -= start;\r\n    value = gap * Math.floor(value / gap);\r\n    return (divide) ? (start + value) / gap : start + value;\r\n}\n\nfunction SnapTo(value, gap, start = 0, divide = false) {\r\n    if (gap === 0) {\r\n        return value;\r\n    }\r\n    value -= start;\r\n    value = gap * Math.round(value / gap);\r\n    return (divide) ? (start + value) / gap : start + value;\r\n}\n\nvar index$f = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    SnapCeil: SnapCeil,\n    SnapFloor: SnapFloor,\n    SnapTo: SnapTo\n});\n\nvar index$g = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Vec2: Vec2\n});\n\nfunction Average(values) {\r\n    let sum = 0;\r\n    for (let i = 0; i < values.length; i++) {\r\n        sum += (+values[i]);\r\n    }\r\n    return sum / values.length;\r\n}\n\nfunction Between(min, max) {\r\n    return Math.floor(Math.random() * (max - min + 1) + min);\r\n}\n\nfunction CeilTo(value, place = 0, base = 10) {\r\n    const p = Math.pow(base, -place);\r\n    return Math.ceil(value * p) / p;\r\n}\n\nfunction Clamp(value, min, max) {\r\n    return Math.max(min, Math.min(max, value));\r\n}\n\nfunction DegToRad(degrees) {\r\n    return degrees * MATH_CONST.DEG_TO_RAD;\r\n}\n\nfunction Difference(a, b) {\r\n    return Math.abs(a - b);\r\n}\n\nfunction FloatBetween(min, max) {\r\n    return Math.random() * (max - min) + min;\r\n}\n\nfunction FloorTo(value, place = 0, base = 10) {\r\n    const p = Math.pow(base, -place);\r\n    return Math.floor(value * p) / p;\r\n}\n\nfunction FromPercent(percent, min, max) {\r\n    percent = Clamp(percent, 0, 1);\r\n    return (max - min) * percent;\r\n}\n\nfunction GetSpeed(distance, time) {\r\n    return (distance / time) / 1000;\r\n}\n\nfunction MaxAdd(value, amount, max) {\r\n    return Math.min(value + amount, max);\r\n}\n\nfunction MinSub(value, amount, min) {\r\n    return Math.max(value - amount, min);\r\n}\n\nfunction Percent(value, min, max, upperMax) {\r\n    if (max === undefined) {\r\n        max = min + 1;\r\n    }\r\n    let percentage = (value - min) / (max - min);\r\n    if (percentage > 1) {\r\n        if (upperMax !== undefined) {\r\n            percentage = ((upperMax - value)) / (upperMax - max);\r\n            if (percentage < 0) {\r\n                percentage = 0;\r\n            }\r\n        }\r\n        else {\r\n            percentage = 1;\r\n        }\r\n    }\r\n    else if (percentage < 0) {\r\n        percentage = 0;\r\n    }\r\n    return percentage;\r\n}\n\nfunction RadToDeg(radians) {\r\n    return radians * MATH_CONST.RAD_TO_DEG;\r\n}\n\nfunction RoundAwayFromZero(value) {\r\n    return (value > 0) ? Math.ceil(value) : Math.floor(value);\r\n}\n\nfunction RoundTo(value, place = 0, base = 10) {\r\n    const p = Math.pow(base, -place);\r\n    return Math.round(value * p) / p;\r\n}\n\nfunction SinCosTableGenerator(length, sinAmp = 1, cosAmp = 1, frequency = 1) {\r\n    frequency *= Math.PI / length;\r\n    const cos = [];\r\n    const sin = [];\r\n    for (let c = 0; c < length; c++) {\r\n        cosAmp -= sinAmp * frequency;\r\n        sinAmp += cosAmp * frequency;\r\n        cos[c] = cosAmp;\r\n        sin[c] = sinAmp;\r\n    }\r\n    return {\r\n        sin,\r\n        cos,\r\n        length\r\n    };\r\n}\n\nfunction ToXY(index, width, height, out = new Vec2()) {\r\n    let x = 0;\r\n    let y = 0;\r\n    const total = width * height;\r\n    if (index > 0 && index <= total) {\r\n        if (index > width - 1) {\r\n            y = Math.floor(index / width);\r\n            x = index - (y * width);\r\n        }\r\n        else {\r\n            x = index;\r\n        }\r\n        out.set(x, y);\r\n    }\r\n    return out;\r\n}\n\nfunction TransformXY(x, y, positionX, positionY, rotation, scaleX, scaleY, output = new Vec2()) {\r\n    const radianSin = Math.sin(rotation);\r\n    const radianCos = Math.cos(rotation);\r\n    const a = radianCos * scaleX;\r\n    const b = radianSin * scaleX;\r\n    const c = -radianSin * scaleY;\r\n    const d = radianCos * scaleY;\r\n    const id = 1 / ((a * d) + (c * -b));\r\n    output.x = (d * id * x) + (-c * id * y) + (((positionY * c) - (positionX * d)) * id);\r\n    output.y = (a * id * y) + (-b * id * x) + (((-positionY * a) + (positionX * b)) * id);\r\n    return output;\r\n}\n\nfunction Within(a, b, tolerance) {\r\n    return (Math.abs(a - b) <= tolerance);\r\n}\n\nvar index$h = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Angle: index$7,\n    Distance: index$8,\n    Fuzzy: index$a,\n    Interpolation: index$b,\n    Matrix2d: index$c,\n    Matrix2dFuncs: index$d,\n    Pow2: index$e,\n    Snap: index$f,\n    Vec2: index$g,\n    Average: Average,\n    Bernstein: Bernstein,\n    Between: Between,\n    CatmullRom: CatmullRom,\n    CeilTo: CeilTo,\n    Clamp: Clamp,\n    MATH_CONST: MATH_CONST,\n    DegToRad: DegToRad,\n    Difference: Difference,\n    Factorial: Factorial,\n    FloatBetween: FloatBetween,\n    FloorTo: FloorTo,\n    FromPercent: FromPercent,\n    GetSpeed: GetSpeed,\n    Linear: Linear,\n    MaxAdd: MaxAdd,\n    MinSub: MinSub,\n    Percent: Percent,\n    RadToDeg: RadToDeg,\n    RoundAwayFromZero: RoundAwayFromZero,\n    RoundTo: RoundTo,\n    SinCosTableGenerator: SinCosTableGenerator,\n    SmootherStep: SmootherStep,\n    SmoothStep: SmoothStep,\n    ToXY: ToXY,\n    TransformXY: TransformXY,\n    Within: Within,\n    Wrap: Wrap\n});\n\nconst Arne16 = [\r\n    '#000',\r\n    '#9D9D9D',\r\n    '#FFF',\r\n    '#BE2633',\r\n    '#E06F8B',\r\n    '#493C2B',\r\n    '#A46422',\r\n    '#EB8931',\r\n    '#F7E26B',\r\n    '#2F484E',\r\n    '#44891A',\r\n    '#A3CE27',\r\n    '#1B2632',\r\n    '#005784',\r\n    '#31A2F2',\r\n    '#B2DCEF'\r\n];\n\nconst C64 = [\r\n    '#000',\r\n    '#fff',\r\n    '#8b4131',\r\n    '#7bbdc5',\r\n    '#8b41ac',\r\n    '#6aac41',\r\n    '#3931a4',\r\n    '#d5de73',\r\n    '#945a20',\r\n    '#5a4100',\r\n    '#bd736a',\r\n    '#525252',\r\n    '#838383',\r\n    '#acee8b',\r\n    '#7b73de',\r\n    '#acacac'\r\n];\n\nconst CGA = [\r\n    '#000',\r\n    '#2234d1',\r\n    '#0c7e45',\r\n    '#44aacc',\r\n    '#8a3622',\r\n    '#5c2e78',\r\n    '#aa5c3d',\r\n    '#b5b5b5',\r\n    '#5e606e',\r\n    '#4c81fb',\r\n    '#6cd947',\r\n    '#7be2f9',\r\n    '#eb8a60',\r\n    '#e23d69',\r\n    '#ffd93f',\r\n    '#fff'\r\n];\n\nconst JMP = [\r\n    '#000',\r\n    '#191028',\r\n    '#46af45',\r\n    '#a1d685',\r\n    '#453e78',\r\n    '#7664fe',\r\n    '#833129',\r\n    '#9ec2e8',\r\n    '#dc534b',\r\n    '#e18d79',\r\n    '#d6b97b',\r\n    '#e9d8a1',\r\n    '#216c4b',\r\n    '#d365c8',\r\n    '#afaab9',\r\n    '#f5f4eb'\r\n];\n\nconst MSX = [\r\n    '#000',\r\n    '#191028',\r\n    '#46af45',\r\n    '#a1d685',\r\n    '#453e78',\r\n    '#7664fe',\r\n    '#833129',\r\n    '#9ec2e8',\r\n    '#dc534b',\r\n    '#e18d79',\r\n    '#d6b97b',\r\n    '#e9d8a1',\r\n    '#216c4b',\r\n    '#d365c8',\r\n    '#afaab9',\r\n    '#fff'\r\n];\n\nconst PICO8 = [\r\n    '#000',\r\n    '#1D2B53',\r\n    '#7E2553',\r\n    '#008751',\r\n    '#AB5236',\r\n    '#5F574F',\r\n    '#C2C3C7',\r\n    '#FFF1E8',\r\n    '#FF004D',\r\n    '#FFA300',\r\n    '#FFEC27',\r\n    '#00E436',\r\n    '#29ADFF',\r\n    '#83769C',\r\n    '#FF77A8',\r\n    '#FFCCAA'\r\n];\n\nvar index$i = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    Arne16: Arne16,\n    C64: C64,\n    CGA: CGA,\n    JMP: JMP,\n    MSX: MSX,\n    PICO8: PICO8\n});\n\nfunction AtlasParser(texture, data) {\r\n    let frames;\r\n    if (Array.isArray(data.textures)) {\r\n        frames = data.textures[0].frames;\r\n    }\r\n    else if (Array.isArray(data.frames)) {\r\n        frames = data.frames;\r\n    }\r\n    else if (data.hasOwnProperty('frames')) {\r\n        frames = Object.values(data.frames);\r\n    }\r\n    else {\r\n        console.warn('Invalid Texture Atlas JSON');\r\n    }\r\n    if (frames) {\r\n        let newFrame;\r\n        for (let i = 0; i < frames.length; i++) {\r\n            const src = frames[i];\r\n            newFrame = texture.add(src.filename, src.frame.x, src.frame.y, src.frame.w, src.frame.h);\r\n            if (src.trimmed) {\r\n                newFrame.setTrim(src.sourceSize.w, src.sourceSize.h, src.spriteSourceSize.x, src.spriteSourceSize.y, src.spriteSourceSize.w, src.spriteSourceSize.h);\r\n            }\r\n            else {\r\n                newFrame.setSourceSize(src.sourceSize.w, src.sourceSize.h);\r\n            }\r\n            if (src.rotated) ;\r\n            if (src.anchor) {\r\n                newFrame.setPivot(src.anchor.x, src.anchor.y);\r\n            }\r\n        }\r\n    }\r\n}\n\nfunction GetValue(node, attribute) {\r\n    return parseInt(node.getAttribute(attribute), 10);\r\n}\r\nfunction BitmapTextParser(texture, xml, frame) {\r\n    const xSpacing = 0;\r\n    const ySpacing = 0;\r\n    const info = xml.getElementsByTagName('info')[0];\r\n    const common = xml.getElementsByTagName('common')[0];\r\n    const data = {\r\n        font: info.getAttribute('face'),\r\n        size: GetValue(info, 'size'),\r\n        lineHeight: GetValue(common, 'lineHeight') + ySpacing,\r\n        chars: {}\r\n    };\r\n    const letters = xml.getElementsByTagName('char');\r\n    for (let i = 0; i < letters.length; i++) {\r\n        const node = letters[i];\r\n        const charCode = GetValue(node, 'id');\r\n        const x = GetValue(node, 'x');\r\n        const y = GetValue(node, 'y');\r\n        const width = GetValue(node, 'width');\r\n        const height = GetValue(node, 'height');\r\n        data.chars[charCode] =\r\n            {\r\n                x,\r\n                y,\r\n                width,\r\n                height,\r\n                xOffset: GetValue(node, 'xoffset'),\r\n                yOffset: GetValue(node, 'yoffset'),\r\n                xAdvance: GetValue(node, 'xadvance') + xSpacing,\r\n                kerning: {}\r\n            };\r\n        texture.add(charCode, x, y, width, height);\r\n    }\r\n    const kernings = xml.getElementsByTagName('kerning');\r\n    for (let i = 0; i < kernings.length; i++) {\r\n        const kern = kernings[i];\r\n        const first = GetValue(kern, 'first');\r\n        const second = GetValue(kern, 'second');\r\n        const amount = GetValue(kern, 'amount');\r\n        data.chars[second].kerning[first] = amount;\r\n    }\r\n    return data;\r\n}\n\nfunction SpriteSheetParser(texture, x, y, width, height, frameConfig) {\r\n    const { frameWidth = null, endFrame = -1, margin = 0, spacing = 0 } = frameConfig;\r\n    let { frameHeight = null, startFrame = 0 } = frameConfig;\r\n    if (!frameHeight) {\r\n        frameHeight = frameWidth;\r\n    }\r\n    if (frameWidth === null) {\r\n        throw new Error('SpriteSheetParser: Invalid frameWidth');\r\n    }\r\n    const row = Math.floor((width - margin + spacing) / (frameWidth + spacing));\r\n    const column = Math.floor((height - margin + spacing) / (frameHeight + spacing));\r\n    let total = row * column;\r\n    if (total === 0) {\r\n        console.warn('SpriteSheetParser: Frame config will result in zero frames');\r\n    }\r\n    if (startFrame > total || startFrame < -total) {\r\n        startFrame = 0;\r\n    }\r\n    if (startFrame < 0) {\r\n        startFrame = total + startFrame;\r\n    }\r\n    if (endFrame !== -1) {\r\n        total = startFrame + (endFrame + 1);\r\n    }\r\n    let fx = margin;\r\n    let fy = margin;\r\n    let ax = 0;\r\n    let ay = 0;\r\n    for (let i = 0; i < total; i++) {\r\n        ax = 0;\r\n        ay = 0;\r\n        const w = fx + frameWidth;\r\n        const h = fy + frameHeight;\r\n        if (w > width) {\r\n            ax = w - width;\r\n        }\r\n        if (h > height) {\r\n            ay = h - height;\r\n        }\r\n        texture.add(i, x + fx, y + fy, frameWidth - ax, frameHeight - ay);\r\n        fx += frameWidth + spacing;\r\n        if (fx + frameWidth > width) {\r\n            fx = margin;\r\n            fy += frameHeight + spacing;\r\n        }\r\n    }\r\n}\n\nvar index$j = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    AtlasParser: AtlasParser,\n    BitmapTextParser: BitmapTextParser,\n    SpriteSheetParser: SpriteSheetParser\n});\n\nfunction GridTexture(color1, color2, width = 32, height = 32, cols = 2, rows = 2) {\r\n    const ctx = CreateCanvas(width, height);\r\n    const colWidth = width / cols;\r\n    const rowHeight = height / rows;\r\n    ctx.fillStyle = color1;\r\n    ctx.fillRect(0, 0, width, height);\r\n    ctx.fillStyle = color2;\r\n    for (let y = 0; y < rows; y++) {\r\n        for (let x = (y % 2); x < cols; x += 2) {\r\n            ctx.fillRect(x * colWidth, y * rowHeight, colWidth, rowHeight);\r\n        }\r\n    }\r\n    return new Texture(ctx.canvas);\r\n}\n\nfunction PixelTexture(config) {\r\n    const { data = [], palette = Arne16, pixelWidth = 1, pixelHeight = pixelWidth, preRender = null, postRender = null } = config;\r\n    let { canvas = null, resizeCanvas = true, clearCanvas = true } = config;\r\n    const width = Math.floor(Math.abs(data[0].length * pixelWidth));\r\n    const height = Math.floor(Math.abs(data.length * pixelHeight));\r\n    if (!canvas) {\r\n        canvas = CreateCanvas(width, height).canvas;\r\n        resizeCanvas = false;\r\n        clearCanvas = false;\r\n    }\r\n    if (resizeCanvas) {\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n    }\r\n    const ctx = canvas.getContext('2d');\r\n    if (clearCanvas) {\r\n        ctx.clearRect(0, 0, width, height);\r\n    }\r\n    if (preRender) {\r\n        preRender(canvas, ctx);\r\n    }\r\n    for (let y = 0; y < data.length; y++) {\r\n        const row = data[y];\r\n        for (let x = 0; x < row.length; x++) {\r\n            const d = row[x];\r\n            if (d !== '.' && d !== ' ') {\r\n                ctx.fillStyle = palette[parseInt('0x' + d.toUpperCase())];\r\n                ctx.fillRect(x * pixelWidth, y * pixelHeight, pixelWidth, pixelHeight);\r\n            }\r\n        }\r\n    }\r\n    if (postRender) {\r\n        postRender(canvas, ctx);\r\n    }\r\n    return new Texture(canvas);\r\n}\n\nfunction CreateFramebuffer(width, height) {\r\n    const gl = GL.get();\r\n    const texture = CreateGLTexture(null, width, height);\r\n    const framebuffer = gl.createFramebuffer();\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\r\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n    return [texture, framebuffer];\r\n}\n\nfunction Ortho(width, height, near = -1, far = 1) {\r\n    const m00 = -2 * (1 / -width);\r\n    const m11 = -2 * (1 / height);\r\n    const m22 = 2 * (1 / (near - far));\r\n    return new Float32Array([m00, 0, 0, 0, 0, m11, 0, 0, 0, 0, m22, 0, -1, 1, 0, 1]);\r\n}\n\nfunction UploadBuffers(sprite, F32, U32, offset, setTexture = true) {\r\n    if (sprite.dirty.render) {\r\n        sprite.updateVertices();\r\n    }\r\n    const data = sprite.vertexData;\r\n    const textureIndex = sprite.texture.glIndex;\r\n    if (setTexture && textureIndex !== sprite.prevTextureID) {\r\n        sprite.prevTextureID = textureIndex;\r\n        data[4] = textureIndex;\r\n        data[10] = textureIndex;\r\n        data[16] = textureIndex;\r\n        data[22] = textureIndex;\r\n    }\r\n    F32.set(data, offset);\r\n    const color = sprite.vertexColor;\r\n    U32[offset + 5] = color[0];\r\n    U32[offset + 11] = color[2];\r\n    U32[offset + 17] = color[3];\r\n    U32[offset + 23] = color[1];\r\n}\n\nfunction RenderWebGL(sprite, renderer, shader, startActiveTexture) {\r\n    const texture = sprite.texture;\r\n    if (texture.glIndexCounter < startActiveTexture) {\r\n        renderer.requestTexture(texture);\r\n    }\r\n    if (shader.count === shader.batchSize) {\r\n        shader.flush();\r\n    }\r\n    UploadBuffers(sprite, shader.vertexViewF32, shader.vertexViewU32, shader.count * shader.quadElementSize);\r\n    shader.count++;\r\n}\n\nclass RenderTexture extends Texture {\r\n    constructor(renderer, width = 256, height = width) {\r\n        super(null, width, height);\r\n        this.renderer = renderer;\r\n        const [texture, framebuffer] = CreateFramebuffer(width, height);\r\n        this.glTexture = texture;\r\n        this.glFramebuffer = framebuffer;\r\n        this.projectionMatrix = Ortho(width, height);\r\n        this.cameraMatrix = new Float32Array([1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, height, 0, 1]);\r\n    }\r\n    cls() {\r\n        const renderer = this.renderer;\r\n        const gl = renderer.gl;\r\n        renderer.reset(this.glFramebuffer, this.width, this.height);\r\n        gl.clearColor(0, 0, 0, 0);\r\n        gl.clear(gl.COLOR_BUFFER_BIT);\r\n        renderer.reset();\r\n        return this;\r\n    }\r\n    batchStart() {\r\n        const renderer = this.renderer;\r\n        renderer.reset(this.glFramebuffer, this.width, this.height);\r\n        renderer.shader.bind(this.projectionMatrix, this.cameraMatrix);\r\n        return this;\r\n    }\r\n    batchDraw(sprites) {\r\n        const renderer = this.renderer;\r\n        const shader = renderer.shader;\r\n        for (let i = 0, len = sprites.length; i < len; i++) {\r\n            RenderWebGL(sprites[i], renderer, shader, renderer.startActiveTexture);\r\n        }\r\n        return this;\r\n    }\r\n    batchEnd() {\r\n        const renderer = this.renderer;\r\n        const shader = renderer.shader;\r\n        shader.flush();\r\n        renderer.reset();\r\n        return this;\r\n    }\r\n    draw(...sprites) {\r\n        this.batchStart();\r\n        this.batchDraw(sprites);\r\n        this.batchEnd();\r\n        return this;\r\n    }\r\n}\n\nfunction SolidColorTexture(color = 'rgba(0,0,0,0)', width = 32, height = 32) {\r\n    const ctx = CreateCanvas(width, height);\r\n    ctx.fillStyle = color;\r\n    ctx.fillRect(0, 0, width, height);\r\n    return new Texture(ctx.canvas);\r\n}\n\nvar index$k = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    CanvasTexture: CanvasTexture,\n    GridTexture: GridTexture,\n    PixelTexture: PixelTexture,\n    RenderTexture: RenderTexture,\n    SolidColorTexture: SolidColorTexture\n});\n\nclass TextureManager {\r\n    constructor() {\r\n        this.textures = new Map();\r\n        this.createDefaultTextures();\r\n        TextureManagerInstance.set(this);\r\n    }\r\n    createDefaultTextures() {\r\n        this.add('__BLANK', new Texture(CreateCanvas(32, 32).canvas));\r\n        const missing = CreateCanvas(32, 32);\r\n        missing.strokeStyle = '#0f0';\r\n        missing.moveTo(0, 0);\r\n        missing.lineTo(32, 32);\r\n        missing.stroke();\r\n        missing.strokeRect(0.5, 0.5, 31, 31);\r\n        this.add('__MISSING', new Texture(missing.canvas));\r\n    }\r\n    get(key) {\r\n        const textures = this.textures;\r\n        if (textures.has(key)) {\r\n            return textures.get(key);\r\n        }\r\n        else {\r\n            return textures.get('__MISSING');\r\n        }\r\n    }\r\n    has(key) {\r\n        return this.textures.has(key);\r\n    }\r\n    add(key, source) {\r\n        let texture;\r\n        const textures = this.textures;\r\n        if (!textures.has(key)) {\r\n            if (source instanceof Texture) {\r\n                texture = source;\r\n            }\r\n            else {\r\n                texture = new Texture(source);\r\n            }\r\n            texture.key = key;\r\n            if (!texture.glTexture) {\r\n                texture.createGL();\r\n            }\r\n            textures.set(key, texture);\r\n        }\r\n        return texture;\r\n    }\r\n}\n\nvar index$l = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    CreateCanvas: CreateCanvas,\n    Frame: Frame,\n    Palettes: index$i,\n    Parsers: index$j,\n    Types: index$k,\n    Texture: Texture,\n    TextureManager: TextureManager\n});\n\nfunction AddDelayedCall(world, delay, callback) {\r\n    AddTimer(world, {\r\n        duration: 0,\r\n        delay,\r\n        onComplete: callback\r\n    });\r\n}\n\nclass Clock {\r\n    constructor(world) {\r\n        this.world = world;\r\n        this.timeScale = 1;\r\n        this.events = new Set();\r\n    }\r\n    update(delta, time) {\r\n        this.now = time;\r\n        delta *= this.timeScale;\r\n        this.events.forEach(timer => {\r\n            if (timer.update(delta)) {\r\n                this.events.delete(timer);\r\n            }\r\n        });\r\n    }\r\n}\n\nvar index$m = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    AddDelayedCall: AddDelayedCall,\n    AddTimer: AddTimer,\n    Clock: Clock,\n    NOOP: NOOP\n});\n\nlet bgColor = 0;\r\nfunction GetBackgroundColor() {\r\n    return bgColor;\r\n}\n\nlet title = 'Phaser';\r\nlet url = 'https://phaser4.io';\r\nlet color = '#fff';\r\nlet background = 'linear-gradient(#3e0081 40%, #00bcc3)';\r\nfunction GetBanner() {\r\n    {\r\n        const game = GameInstance.get();\r\n        const version =  ' v' + game.VERSION ;\r\n        console.log(`%c${title}${version}%c ${url}`, `padding: 4px 16px; color: ${color}; background: ${background}`, '');\r\n    }\r\n}\n\nlet _width = 800;\r\nlet _height = 600;\r\nlet _resolution = 1;\r\nfunction GetWidth() {\r\n    return _width;\r\n}\r\nfunction GetHeight() {\r\n    return _height;\r\n}\r\nfunction GetResolution() {\r\n    return _resolution;\r\n}\n\nlet instance$2;\r\nfunction GetRenderer() {\r\n    return instance$2;\r\n}\n\nlet _scenes = [];\r\nfunction GetScenes() {\r\n    return _scenes;\r\n}\n\nlet _contextAttributes = {\r\n    alpha: false,\r\n    antialias: false,\r\n    depth: false,\r\n    premultipliedAlpha: false\r\n};\r\nfunction GetWebGLContext() {\r\n    return _contextAttributes;\r\n}\n\nconst fragTemplate = [\r\n    'precision mediump float;',\r\n    'void main(void){',\r\n    'float test = 0.1;',\r\n    '%forloop%',\r\n    'gl_FragColor = vec4(0.0);',\r\n    '}'\r\n].join('\\n');\r\nfunction GenerateSrc(maxIfs) {\r\n    let src = '';\r\n    for (let i = 0; i < maxIfs; ++i) {\r\n        if (i > 0) {\r\n            src += '\\nelse ';\r\n        }\r\n        if (i < maxIfs - 1) {\r\n            src += `if(test == ${i}.0){}`;\r\n        }\r\n    }\r\n    return src;\r\n}\r\nfunction CheckShaderMaxIfStatements(maxIfs, gl) {\r\n    const shader = gl.createShader(gl.FRAGMENT_SHADER);\r\n    while (true) {\r\n        const fragmentSrc = fragTemplate.replace(/%forloop%/gi, GenerateSrc(maxIfs));\r\n        gl.shaderSource(shader, fragmentSrc);\r\n        gl.compileShader(shader);\r\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n            maxIfs = (maxIfs / 2) | 0;\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n    return maxIfs;\r\n}\n\nconst shaderSource = {\r\n    fragmentShader: `\r\nprecision highp float;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying float vTextureId;\r\nvarying vec4 vTintColor;\r\n\r\nuniform sampler2D uTexture[%count%];\r\n\r\nvoid main (void)\r\n{\r\n    vec4 color;\r\n    %forloop%\r\n\r\n    gl_FragColor = color * vec4(vTintColor.bgr * vTintColor.a, vTintColor.a);\r\n}`,\r\n    vertexShader: `\r\nprecision highp float;\r\n\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\nattribute float aTextureId;\r\nattribute vec4 aTintColor;\r\n\r\nuniform mat4 uProjectionMatrix;\r\nuniform mat4 uCameraMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying float vTextureId;\r\nvarying vec4 vTintColor;\r\n\r\nvoid main (void)\r\n{\r\n    vTextureCoord = aTextureCoord;\r\n    vTextureId = aTextureId;\r\n    vTintColor = aTintColor;\r\n\r\n    gl_Position = uProjectionMatrix * uCameraMatrix * vec4(aVertexPosition, 0.0, 1.0);\r\n}`\r\n};\r\nclass MultiTextureQuadShader {\r\n    constructor(renderer, config = {}) {\r\n        this.attribs = { aVertexPosition: 0, aTextureCoord: 0, aTextureId: 0, aTintColor: 0 };\r\n        this.uniforms = { uProjectionMatrix: 0, uCameraMatrix: 0, uTexture: 0 };\r\n        this.dataSize = 4;\r\n        this.indexSize = 4;\r\n        this.vertexElementSize = 6;\r\n        this.vertexByteSize = 6 * 4;\r\n        this.quadByteSize = (6 * 4) * 4;\r\n        this.quadElementSize = 6 * 4;\r\n        this.quadIndexSize = 6;\r\n        this.renderer = renderer;\r\n        this.gl = renderer.gl;\r\n        const { batchSize = 4096, fragmentShader = shaderSource.fragmentShader, vertexShader = shaderSource.vertexShader } = config;\r\n        this.batchSize = batchSize;\r\n        this.bufferByteSize = batchSize * this.quadByteSize;\r\n        this.createBuffers();\r\n        this.createShaders(fragmentShader, vertexShader);\r\n        this.count = 0;\r\n    }\r\n    createBuffers() {\r\n        let ibo = [];\r\n        for (let i = 0; i < (this.batchSize * this.indexSize); i += this.indexSize) {\r\n            ibo.push(i + 0, i + 1, i + 2, i + 2, i + 3, i + 0);\r\n        }\r\n        this.data = new ArrayBuffer(this.bufferByteSize);\r\n        this.index = new Uint16Array(ibo);\r\n        this.vertexViewF32 = new Float32Array(this.data);\r\n        this.vertexViewU32 = new Uint32Array(this.data);\r\n        const gl = this.gl;\r\n        this.vertexBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, this.data, gl.DYNAMIC_DRAW);\r\n        this.indexBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.index, gl.STATIC_DRAW);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n        ibo = [];\r\n    }\r\n    createShaders(fragmentShaderSource, vertexShaderSource) {\r\n        const gl = this.gl;\r\n        const maxTextures = this.renderer.maxTextures;\r\n        let src = '';\r\n        if (maxTextures > 1) {\r\n            for (let i = 0; i < maxTextures; i++) {\r\n                if (i > 0) {\r\n                    src += '\\nelse ';\r\n                }\r\n                if (i < maxTextures - 1) {\r\n                    src += `if (vTextureId < ${i}.5)`;\r\n                }\r\n                src += '\\n{';\r\n                src += `\\n  color = texture2D(uTexture[${i}], vTextureCoord);`;\r\n                src += '\\n}';\r\n            }\r\n            fragmentShaderSource = fragmentShaderSource.replace(/%count%/gi, `${maxTextures}`);\r\n            fragmentShaderSource = fragmentShaderSource.replace(/%forloop%/gi, src);\r\n        }\r\n        else {\r\n            src = 'color = texture2D(uTexture[0], vTextureCoord);';\r\n        }\r\n        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\r\n        gl.shaderSource(fragmentShader, fragmentShaderSource);\r\n        gl.compileShader(fragmentShader);\r\n        const vertexShader = gl.createShader(gl.VERTEX_SHADER);\r\n        gl.shaderSource(vertexShader, vertexShaderSource);\r\n        gl.compileShader(vertexShader);\r\n        const program = gl.createProgram();\r\n        gl.attachShader(program, vertexShader);\r\n        gl.attachShader(program, fragmentShader);\r\n        gl.linkProgram(program);\r\n        gl.useProgram(program);\r\n        this.program = program;\r\n        for (const key of Object.keys(this.attribs)) {\r\n            const location = gl.getAttribLocation(program, key);\r\n            gl.enableVertexAttribArray(location);\r\n            this.attribs[key] = location;\r\n        }\r\n        for (const key of Object.keys(this.uniforms)) {\r\n            this.uniforms[key] = gl.getUniformLocation(program, key);\r\n        }\r\n    }\r\n    bind(projectionMatrix, cameraMatrix) {\r\n        const gl = this.gl;\r\n        const renderer = this.renderer;\r\n        const uniforms = this.uniforms;\r\n        gl.useProgram(this.program);\r\n        gl.uniformMatrix4fv(uniforms.uProjectionMatrix, false, projectionMatrix);\r\n        gl.uniformMatrix4fv(uniforms.uCameraMatrix, false, cameraMatrix);\r\n        gl.uniform1iv(uniforms.uTexture, renderer.textureIndex);\r\n        this.bindBuffers(this.indexBuffer, this.vertexBuffer);\r\n    }\r\n    bindBuffers(indexBuffer, vertexBuffer) {\r\n        const gl = this.gl;\r\n        const stride = this.vertexByteSize;\r\n        const attribs = this.attribs;\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n        gl.vertexAttribPointer(attribs.aVertexPosition, 2, gl.FLOAT, false, stride, 0);\r\n        gl.vertexAttribPointer(attribs.aTextureCoord, 2, gl.FLOAT, false, stride, 8);\r\n        gl.vertexAttribPointer(attribs.aTextureId, 1, gl.FLOAT, false, stride, 16);\r\n        gl.vertexAttribPointer(attribs.aTintColor, 4, gl.UNSIGNED_BYTE, true, stride, 20);\r\n        this.count = 0;\r\n    }\r\n    draw(count) {\r\n        const gl = this.gl;\r\n        const offset = count * this.quadByteSize;\r\n        if (offset === this.bufferByteSize) {\r\n            gl.bufferData(gl.ARRAY_BUFFER, this.data, gl.DYNAMIC_DRAW);\r\n        }\r\n        else {\r\n            const view = this.vertexViewF32.subarray(0, offset);\r\n            gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);\r\n        }\r\n        gl.drawElements(gl.TRIANGLES, count * this.quadIndexSize, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n    flush() {\r\n        const count = this.count;\r\n        if (count === 0) {\r\n            return false;\r\n        }\r\n        this.draw(count);\r\n        this.prevCount = count;\r\n        this.count = 0;\r\n        this.renderer.flushTotal++;\r\n        return true;\r\n    }\r\n}\n\nclass WebGLRenderer {\r\n    constructor() {\r\n        this.clearColor = [0, 0, 0, 1];\r\n        this.flushTotal = 0;\r\n        this.maxTextures = 0;\r\n        this.currentActiveTexture = 0;\r\n        this.startActiveTexture = 0;\r\n        this.tempTextures = [];\r\n        this.clearBeforeRender = true;\r\n        this.optimizeRedraw = true;\r\n        this.autoResize = true;\r\n        this.contextLost = false;\r\n        this.width = GetWidth();\r\n        this.height = GetHeight();\r\n        this.resolution = GetResolution();\r\n        this.setBackgroundColor(GetBackgroundColor());\r\n        const canvas = document.createElement('canvas');\r\n        canvas.addEventListener('webglcontextlost', (event) => this.onContextLost(event), false);\r\n        canvas.addEventListener('webglcontextrestored', () => this.onContextRestored(), false);\r\n        this.canvas = canvas;\r\n        this.initContext();\r\n        this.shader = new MultiTextureQuadShader(this);\r\n    }\r\n    initContext() {\r\n        const gl = this.canvas.getContext('webgl', GetWebGLContext());\r\n        GL.set(gl);\r\n        this.gl = gl;\r\n        this.elementIndexExtension = gl.getExtension('OES_element_index_uint');\r\n        this.getMaxTextures();\r\n        if (this.shader) {\r\n            this.shader.gl = gl;\r\n        }\r\n        gl.disable(gl.DEPTH_TEST);\r\n        gl.disable(gl.CULL_FACE);\r\n        this.resize(this.width, this.height, this.resolution);\r\n    }\r\n    resize(width, height, resolution = 1) {\r\n        this.width = width * resolution;\r\n        this.height = height * resolution;\r\n        this.resolution = resolution;\r\n        const canvas = this.canvas;\r\n        canvas.width = this.width;\r\n        canvas.height = this.height;\r\n        if (this.autoResize) {\r\n            canvas.style.width = this.width / resolution + 'px';\r\n            canvas.style.height = this.height / resolution + 'px';\r\n        }\r\n        this.gl.viewport(0, 0, this.width, this.height);\r\n        this.projectionMatrix = Ortho(width, height);\r\n    }\r\n    onContextLost(event) {\r\n        event.preventDefault();\r\n        this.contextLost = true;\r\n    }\r\n    onContextRestored() {\r\n        this.contextLost = false;\r\n        this.initContext();\r\n    }\r\n    setBackgroundColor(color) {\r\n        const clearColor = this.clearColor;\r\n        const r = color >> 16 & 0xFF;\r\n        const g = color >> 8 & 0xFF;\r\n        const b = color & 0xFF;\r\n        const a = (color > 16777215) ? color >>> 24 : 255;\r\n        clearColor[0] = r / 255;\r\n        clearColor[1] = g / 255;\r\n        clearColor[2] = b / 255;\r\n        clearColor[3] = a / 255;\r\n        return this;\r\n    }\r\n    getMaxTextures() {\r\n        const gl = this.gl;\r\n        const maxTextures = CheckShaderMaxIfStatements(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), gl);\r\n        const tempTextures = this.tempTextures;\r\n        if (tempTextures.length) {\r\n            tempTextures.forEach(texture => {\r\n                gl.deleteTexture(texture);\r\n            });\r\n        }\r\n        for (let texturesIndex = 0; texturesIndex < maxTextures; texturesIndex++) {\r\n            const tempTexture = gl.createTexture();\r\n            gl.activeTexture(gl.TEXTURE0 + texturesIndex);\r\n            gl.bindTexture(gl.TEXTURE_2D, tempTexture);\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));\r\n            tempTextures[texturesIndex] = tempTexture;\r\n        }\r\n        this.maxTextures = maxTextures;\r\n        this.textureIndex = Array.from(Array(maxTextures).keys());\r\n        this.activeTextures = Array(maxTextures);\r\n        this.currentActiveTexture = 0;\r\n    }\r\n    reset(framebuffer = null, width = this.width, height = this.height) {\r\n        const gl = this.gl;\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\r\n        gl.viewport(0, 0, width, height);\r\n        gl.enable(gl.BLEND);\r\n        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n        this.currentActiveTexture = 0;\r\n        this.startActiveTexture++;\r\n        this.flushTotal = 0;\r\n    }\r\n    render(renderData) {\r\n        if (this.contextLost) {\r\n            return;\r\n        }\r\n        const gl = this.gl;\r\n        this.reset();\r\n        if (this.optimizeRedraw && renderData.numDirtyFrames === 0 && renderData.numDirtyCameras === 0) {\r\n            return;\r\n        }\r\n        const shader = this.shader;\r\n        const cls = this.clearColor;\r\n        if (this.clearBeforeRender) {\r\n            gl.clearColor(cls[0], cls[1], cls[2], cls[3]);\r\n            gl.clear(gl.COLOR_BUFFER_BIT);\r\n        }\r\n        const projectionMatrix = this.projectionMatrix;\r\n        let prevCamera;\r\n        const worlds = renderData.worldData;\r\n        for (let i = 0; i < worlds.length; i++) {\r\n            const { camera, renderList, numRendered } = worlds[i];\r\n            if (!prevCamera || !ExactEquals(camera.worldTransform, prevCamera.worldTransform)) {\r\n                shader.flush();\r\n                shader.bind(projectionMatrix, camera.matrix);\r\n                prevCamera = camera;\r\n            }\r\n            for (let s = 0; s < numRendered; s++) {\r\n                RenderWebGL(renderList[s], this, shader, this.startActiveTexture);\r\n            }\r\n        }\r\n        shader.flush();\r\n    }\r\n    resetTextures(texture) {\r\n        const gl = this.gl;\r\n        const active = this.activeTextures;\r\n        active.fill(null);\r\n        this.currentActiveTexture = 0;\r\n        this.startActiveTexture++;\r\n        if (texture) {\r\n            active[0] = texture;\r\n            gl.activeTexture(gl.TEXTURE0);\r\n            gl.bindTexture(gl.TEXTURE_2D, texture.glTexture);\r\n            this.currentActiveTexture = 1;\r\n        }\r\n    }\r\n    requestTexture(texture) {\r\n        const gl = this.gl;\r\n        texture.glIndexCounter = this.startActiveTexture;\r\n        if (this.currentActiveTexture < this.maxTextures) {\r\n            this.activeTextures[this.currentActiveTexture] = texture;\r\n            texture.glIndex = this.currentActiveTexture;\r\n            gl.activeTexture(gl.TEXTURE0 + this.currentActiveTexture);\r\n            gl.bindTexture(gl.TEXTURE_2D, texture.glTexture);\r\n            this.currentActiveTexture++;\r\n        }\r\n        else {\r\n            this.shader.flush();\r\n            this.resetTextures(texture);\r\n        }\r\n    }\r\n}\n\nfunction CreateSceneRenderData() {\r\n    return {\r\n        gameFrame: 0,\r\n        numTotalFrames: 0,\r\n        numDirtyFrames: 0,\r\n        numDirtyCameras: 0,\r\n        worldData: []\r\n    };\r\n}\n\nfunction ResetSceneRenderData(renderData, gameFrame = 0) {\r\n    renderData.gameFrame = gameFrame;\r\n    renderData.numTotalFrames = 0;\r\n    renderData.numDirtyFrames = 0;\r\n    renderData.numDirtyCameras = 0;\r\n    renderData.worldData.length = 0;\r\n}\n\nlet instance$3;\r\nconst SceneManagerInstance = {\r\n    get: () => {\r\n        return instance$3;\r\n    },\r\n    set: (manager) => {\r\n        instance$3 = manager;\r\n    }\r\n};\n\nclass SceneManager {\r\n    constructor() {\r\n        this.scenes = new Map();\r\n        this.sceneIndex = 0;\r\n        this.flush = false;\r\n        this.renderResult = CreateSceneRenderData();\r\n        this.game = GameInstance.get();\r\n        SceneManagerInstance.set(this);\r\n        Once(this.game, 'boot', () => this.boot());\r\n    }\r\n    boot() {\r\n        GetScenes().forEach(scene => new scene());\r\n    }\r\n    update(delta, time) {\r\n        for (const scene of this.scenes.values()) {\r\n            Emit(scene, 'update', delta, time);\r\n        }\r\n    }\r\n    render(gameFrame) {\r\n        const results = this.renderResult;\r\n        ResetSceneRenderData(results, gameFrame);\r\n        for (const scene of this.scenes.values()) {\r\n            Emit(scene, 'render', results);\r\n        }\r\n        if (this.flush) {\r\n            results.numDirtyFrames++;\r\n            this.flush = false;\r\n        }\r\n        return results;\r\n    }\r\n}\n\nclass Game extends EventEmitter {\r\n    constructor(...settings) {\r\n        super();\r\n        this.VERSION = '4.0.0-beta1';\r\n        this.isBooted = false;\r\n        this.isPaused = false;\r\n        this.willUpdate = true;\r\n        this.willRender = true;\r\n        this.lastTick = 0;\r\n        this.frame = 0;\r\n        GameInstance.set(this);\r\n        DOMContentLoaded(() => this.boot(settings));\r\n    }\r\n    boot(settings) {\r\n        settings.forEach(setting => setting());\r\n        const renderer = GetRenderer();\r\n        this.renderer = new renderer();\r\n        this.textureManager = new TextureManager();\r\n        this.sceneManager = new SceneManager();\r\n        this.isBooted = true;\r\n        GetBanner();\r\n        Emit(this, 'boot');\r\n        this.lastTick = performance.now();\r\n        this.step(this.lastTick);\r\n    }\r\n    pause() {\r\n        this.isPaused = true;\r\n    }\r\n    resume() {\r\n        this.isPaused = false;\r\n        this.lastTick = performance.now();\r\n    }\r\n    step(time) {\r\n        const delta = time - this.lastTick;\r\n        this.lastTick = time;\r\n        if (!this.isPaused) {\r\n            if (this.willUpdate) {\r\n                this.sceneManager.update(delta, time);\r\n            }\r\n            if (this.willRender) {\r\n                this.renderer.render(this.sceneManager.render(this.frame));\r\n            }\r\n        }\r\n        this.frame++;\r\n        GameInstance.setFrame(this.frame);\r\n        requestAnimationFrame(now => this.step(now));\r\n    }\r\n    destroy() {\r\n    }\r\n}\n\nclass Loader extends EventEmitter {\r\n    constructor() {\r\n        super();\r\n        this.baseURL = '';\r\n        this.path = '';\r\n        this.crossOrigin = 'anonymous';\r\n        this.maxParallelDownloads = -1;\r\n        this.isLoading = false;\r\n        this.reset();\r\n    }\r\n    reset() {\r\n        this.isLoading = false;\r\n        this.queue = new Set();\r\n        this.inflight = new Set();\r\n        this.completed = new Set();\r\n        this.progress = 0;\r\n    }\r\n    add(...file) {\r\n        file.forEach(entity => {\r\n            entity.loader = this;\r\n            this.queue.add(entity);\r\n        });\r\n        return this;\r\n    }\r\n    start(onComplete) {\r\n        if (this.isLoading) {\r\n            return this;\r\n        }\r\n        this.completed.clear();\r\n        this.progress = 0;\r\n        if (this.queue.size > 0) {\r\n            this.isLoading = true;\r\n            this.onComplete = onComplete;\r\n            Emit(this, 'start');\r\n            this.nextFile();\r\n        }\r\n        else {\r\n            this.progress = 1;\r\n            Emit(this, 'complete');\r\n            onComplete();\r\n        }\r\n        return this;\r\n    }\r\n    nextFile() {\r\n        let limit = this.queue.size;\r\n        if (this.maxParallelDownloads !== -1) {\r\n            limit = Math.min(limit, this.maxParallelDownloads) - this.inflight.size;\r\n        }\r\n        if (limit) {\r\n            const iterator = this.queue.values();\r\n            while (limit > 0) {\r\n                const file = iterator.next().value;\r\n                this.inflight.add(file);\r\n                this.queue.delete(file);\r\n                file.load().then((file) => this.fileComplete(file)).catch((file) => this.fileError(file));\r\n                limit--;\r\n            }\r\n        }\r\n        else if (this.inflight.size === 0) {\r\n            this.stop();\r\n        }\r\n    }\r\n    stop() {\r\n        this.isLoading = false;\r\n        Emit(this, 'complete', this.completed);\r\n        this.onComplete();\r\n        this.completed.clear();\r\n    }\r\n    updateProgress(file) {\r\n        this.inflight.delete(file);\r\n        this.completed.add(file);\r\n        const totalCompleted = this.completed.size;\r\n        const totalQueued = this.queue.size + this.inflight.size;\r\n        if (totalCompleted > 0) {\r\n            this.progress = totalCompleted / (totalCompleted + totalQueued);\r\n        }\r\n        Emit(this, 'progress', this.progress, totalCompleted, totalQueued);\r\n        this.nextFile();\r\n    }\r\n    fileComplete(file) {\r\n        Emit(this, 'filecomplete', file);\r\n        this.updateProgress(file);\r\n    }\r\n    fileError(file) {\r\n        Emit(this, 'fileerror', file);\r\n        this.updateProgress(file);\r\n    }\r\n    totalFilesToLoad() {\r\n        return this.queue.size + this.inflight.size;\r\n    }\r\n    setBaseURL(url = '') {\r\n        if (url !== '' && url.substr(-1) !== '/') {\r\n            url = url.concat('/');\r\n        }\r\n        this.baseURL = url;\r\n        return this;\r\n    }\r\n    setPath(path = '') {\r\n        if (path !== '' && path.substr(-1) !== '/') {\r\n            path = path.concat('/');\r\n        }\r\n        this.path = path;\r\n        return this;\r\n    }\r\n    setCORS(crossOrigin) {\r\n        this.crossOrigin = crossOrigin;\r\n        return this;\r\n    }\r\n    setMaxParallelDownloads(max) {\r\n        this.maxParallelDownloads = max;\r\n        return this;\r\n    }\r\n}\n\nfunction GetConfigValue(config, property, defaultValue) {\r\n    if (Object.prototype.hasOwnProperty.call(config, property)) {\r\n        return config[property];\r\n    }\r\n    else {\r\n        return defaultValue;\r\n    }\r\n}\n\nfunction Install(scene, config = {}) {\r\n    const sceneManager = SceneManagerInstance.get();\r\n    const size = sceneManager.scenes.size;\r\n    const sceneIndex = sceneManager.sceneIndex;\r\n    const firstScene = (size === 0);\r\n    if (typeof config === 'string') {\r\n        scene.key = config;\r\n    }\r\n    else if (config || (!config && firstScene)) {\r\n        scene.key = GetConfigValue(config, 'key', 'scene' + sceneIndex);\r\n    }\r\n    if (sceneManager.scenes.has(scene.key)) {\r\n        console.warn('Scene key already in use: ' + scene.key);\r\n    }\r\n    else {\r\n        sceneManager.scenes.set(scene.key, scene);\r\n        sceneManager.flush = true;\r\n        sceneManager.sceneIndex++;\r\n    }\r\n}\n\nclass Scene {\r\n    constructor(config) {\r\n        this.game = GameInstance.get();\r\n        this.events = new Map();\r\n        Install(this, config);\r\n    }\r\n}\n\nexport { index as DOM, index$5 as Device, index$6 as Events, Game, index$9 as GameObjects, Loader, index$h as Math, Scene, index$l as Textures, index$m as Time, WebGLRenderer };\n//# sourceMappingURL=Phaser4.esm.js.map\n","import { Game, Scene } from '@phaserjs/phaser';\r\nimport { Parent, Scenes } from '@phaserjs/phaser/config';\r\n\r\nimport { AddChild } from '@phaserjs/phaser/gameobjects/AddChild';\r\nimport { PICO8 } from '@phaserjs/phaser/textures/palettes/PICO8';\r\nimport { PixelTexture } from '@phaserjs/phaser/textures/types/PixelTexture';\r\nimport { Sprite } from '@phaserjs/phaser/gameobjects/sprite/Sprite';\r\nimport { StaticWorld } from '@phaserjs/phaser/world/StaticWorld';\r\n\r\nclass Demo extends Scene\r\n{\r\n    constructor ()\r\n    {\r\n        super();\r\n\r\n        const world = new StaticWorld(this);\r\n\r\n        const texture = PixelTexture({\r\n            data: [\r\n                '..9..9..',\r\n                '..9999..',\r\n                '.AAAAAA.',\r\n                '.A1F1FA.',\r\n                '.AFFFFA.',\r\n                '.FEEEEAA',\r\n                '.EEEEEEA',\r\n                '..E..E..'\r\n            ],\r\n            pixelWidth: 32,\r\n            pixelHeight: 32,\r\n            palette: PICO8\r\n        });\r\n\r\n        const princess = new Sprite(400, 300, texture);\r\n\r\n        AddChild(world, princess);\r\n    }\r\n}\r\n\r\nnew Game(\r\n    Parent('example'),\r\n    Scenes(Demo)\r\n);\r\n"],"names":["StaticWorld","PixelTexture","PICO8","Sprite","AddChild","Parent","Scenes"],"mappings":"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"}